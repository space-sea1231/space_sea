{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	"C++ Template":{
		"prefix": "#File",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"int main(){",
			"    // freopen(\"std.in\", \"r\", stdin);",
			"    // freopen(\"std.out\", \"w\", stdout);",
			"    ios::sync_with_stdio(0);",
			"    cin.tie();",
			"",
			"    return 0;",
			"}",
		],
	},
	"C++ Freopen":{
		"prefix": "#Freopen",
		"body": [
			"freopen(\"std.in\", \"r\", stdin);",
			"freopen(\"std.out\", \"w\", stdout);",
		],
	},
	"C++ Graph":{
		"prefix": "#Graph",
		"body": [
			"int cnt;",
			"int head[N], to[N<<1], nxt[N<<1];",
			"void Add(int u, int v){",
			"    to[++cnt]=v;",
			"    nxt[cnt]=head[u];",
			"    head[u]=cnt;",
			"}",
		],
	},
	"C++ Union_Find":{
		"prefix": "#Union_Find",
		"body": [
			"struct Union_Find{",
			"    int fa[N];",
			"    int Find(int x){",
			"        if (x==fa[x]){",
			"            return x;",
			"        }",
			"        return fa[x]=Find(fa[x]);",
			"    }",
			"    Union_Find(){",
			"        for (int i=1; i<N; i++){",
			"            fa[i]=i;",
			"        }",
			"    }",
			"}",
		],
	},
	"C++ Binary_Indexed_Tree":{
		"prefix": "#Binary_Indexed_Tree",
		"body": [
			"struct Binary_Indexed_Tree{",
			"    int num[N];",
			"    int lowbit(int x){",
			"        return x&-x;",
			"    }",
			"    void add(int x, int y){",
			"        for (int i=x; i<=n; i+=lowbit(i)){",
			"            num[i]+=y;",
			"        }",
			"    }",
			"    int sum(int x){",
			"        int ans=0;",
			"        for (int i=x; i>=1; i-=lowbit(i)){",
			"            ans+=num[i];",
			"        }",
			"        return ans;",
			"    }",
			"};",
		],
	},
	"C++ Segment_Tree_Add":{
		"prefix": "#Segment_Tree_Add",
		"body": [
			"struct Segment_Tree{",
			"    struct Node{",
			"        int sum, vis;",
			"    }e[N<<2];",
			"    void Build(int x, int l, int r){",
			"        if (l==r){",
			"            e[x].sum=a[l];",
			"            return ;",
			"        }",
			"        int mid=(l+r)>>1;",
			"        Build(x<<1, l, mid);",
			"        Build(x<<1|1, mid+1, r);",
			"        e[x].sum=e[x<<1].sum+e[x<<1|1].sum;",
			"    }",
			"    void Down(int x, int l, int r){",
			"        int mid=(l+r)>>1;",
			"        e[x<<1].vis+=e[x].vis;",
			"        e[x<<1|1].vis+=e[x].vis;",
			"        e[x<<1].sum+=(mid-l+1)*e[x].vis;",
			"        e[x<<1|1].sum+=(r-mid)*e[x].vis;",
			"        e[x].vis=0;",
			"    }",
			"    void Add(int x, int l, int r, int L, int R, int w){",
			"        if (L<=l&&r<=R){",
			"            e[x].vis+=w;",
			"            e[x].sum+=(r-l+1)*w;",
			"            return ;",
			"        }",
			"        ",
			"        Down(x, l, r);",
			"        int mid=(l+r)>>1;",
			"        if (L<=mid){",
			"            Add(x<<1, l, mid, L, R, w);",
			"        }",
			"        if (mid+1<=R){",
			"            Add(x<<1|1, mid+1, r, L, R, w);",
			"        }",
			"        e[x].sum=e[x<<1].sum+e[x<<1|1].sum;",
			"    }",
			"    int Query(int x, int l, int r, int L, int R){",
			"        if (L<=l&&r<=R){",
			"            return e[x].sum;",
			"        }",
			"        Down(x, l, r);",
			"        int mid=(l+r)>>1, ans=0;",
			"        if (L<=mid){",
			"            ans+=Query(x<<1, l, mid, L, R);",
			"        }",
			"        if (mid+1<=R){",
			"            ans+=Query(x<<1|1, mid+1, r, L, R);",
			"        }",
			"        return ans;",
			"    }",
			"};",
		],
	},
	"C++ Segment_Tree_Mul":{
		"prefix": "#Segment_Tree_Mul",
		"body": [
			"struct Segment_Tree{",
			"    struct Node{",
			"        int sum, vis_add, vis_mul;",
			"    }e[N<<1];",
			"    void Build(int x, int l, int r){",
			"        int mid=(l+r)>>1;",
			"        e[x].vis_mul=1;",
			"        if (l==r){",
			"            e[x].sum=a[l];",
			"            return;",
			"        }",
			"        Build(x<<1, l, mid);",
			"        Build(x<<1|1, mid+1, r);",
			"        e[x].sum+=e[x<<1|1].sum;",
			"    }",
			"    void Down(int x, int l, int r){",
			"        int mid=(l+r)>>1;",
			"        e[x<<1].sum=e[x<<1].sum*e[x].vis_mul+(mid-l+1)*e[x].vis_add;",
			"        e[x<<1|1].sum=e[x<<1|1].sum*e[x].vis_mul+(r-mid)*e[x].vis_add;",
			"        e[x<<1].vis_add=e[x<<1].vis_add*e[x].vis_mul+e[x].vis_add;",
			"        e[x<<1|1].vis_add=e[x<<1|1].vis_add*e[x].vis_mul+e[x].vis_add;",
			"        e[x<<1].vis_mul*=e[x].vis_mul;",
			"        e[x<<1|1].vis_mul*=e[x].vis_mul;",
			"        e[x].vis_add=0, e[x].vis_mul=1;",
			"    }",
			"    void Mul(int x, int l, int r, int L, int R, int w){",
			"        if (L<=l&&r<=R){",
			"            e[x].vis_add=e[x].vis_add*w;",
			"            e[x].vis_mul=e[x].vis_mul*w;",
			"            e[x].sum=e[x].sum*w;",
			"            return;",
			"        }",
			"        Down(x, l, r);",
			"        int mid=(l+r)>>1;",
			"        if (L<=mid){",
			"            Mul(x<<1, l, mid, L, R, w);",
			"        }",
			"        if (mid+1<=R){",
			"            Mul(x<<1|1, mid+1, r, L, R, w);",
			"        }",
			"        e[x].sum=e[x<<1].sum+e[x<<1|1].sum;",
			"    }",
			"    void Add(int x, int l, int r, int L, int R, int w){",
			"        if (L<=l&&r<=R){",
			"            e[x].vis_add+=w;",
			"            e[x].sum+=(r-l+1)*w;",
			"            return;",
			"        }",
			"        Down(x, l, r);",
			"        int mid=(l+r)>>1;",
			"        if (L<=mid){",
			"            Add(x<<1, l, mid, L, R, w);",
			"        }",
			"        if (mid+1<=R){",
			"            Add(x<<1|1, mid+1, r, L, R, w);",
			"        }",
			"        e[x].sum=e[x<<1].sum+e[x<<1|1].sum;",
			"    }",
			"    int Query(int x, int l, int r, int L, int R){",
			"        if (L<=l&&r<=R){",
			"            return e[x].sum;",
			"        }",
			"        Down(x, l, r);",
			"        int mid=(l+r)>>1, ans=0;",
			"        if (L<=mid){",
			"            ans+=Query(x<<1, l, mid, L, R);",
			"        }",
			"        if (mid+1<=R){",
			"            ans+=Query(x<<1|1, mid+1, r, L, R);",
			"        }",
			"        return ans;",
			"    }",
			"};",
		],
	},
	"C++ Li_Chao_Segment_Tree":{
		"prefix": "#Li_Chao_Segment_Tree",
		"body": [
			"struct Li_Chao_Segment_Tree{",
			"    int cnt;",
			"    int vis[N<<1];",
			"    struct Node{",
			"        double k, b;",
			"    }e[N<<1];",
			"    void Add(int sx, int sy, int fx, int fy){",
			"        cnt++;",
			"        if (sx==sy){",
			"            e[cnt].k=0;",
			"            e[cnt].b=max(sy, fy);",
			"        }else{",
			"            e[cnt].k=1.0*(fy-sy)/(fx-sx);",
			"            e[cnt].b=sy-e[cnt].k*sx;",
			"        }",
			"    }",
			"    double Calc(int x, int val){",
			"        return e[x].k*val+e[x].b;",
			"    }",
			"    int Check(double x, double y){",
			"        if (x-y>eps){",
			"            return 1;",
			"        }",
			"        if (y-x>eps){",
			"            return -1;",
			"        }",
			"        return 0;",
			"    }",
			"    void Down(int root, int l, int r, int u){",
			"        int &v=vis[root], mid=(l+r)>>1;",
			"        int check_mid=Check(Calc(u, mid), Calc(v, mid));",
			"        if (check_mid==1||(check_mid==0&&u<v)){",
			"            swap(u, v);",
			"        }",
			"        int check_l=Check(Calc(u, l), Calc(v, l));",
			"        int check_r=Check(Calc(u, r), Calc(v, r));",
			"        if (check_l==1||(check_l==0&&u<v)){",
			"            Down(root<<1, l, mid, u);",
			"        }",
			"        if (check_r==1||(check_r==0&&u<v)){",
			"            Down(root<<1|1, mid+1, r, u);",
			"        }",
			"    }",
			"    void Update(int root, int l, int r, int L, int R, int u){",
			"        if (L<=l&&r<=R){",
			"            Down(root, l, r, u);",
			"            return ;",
			"        }",
			"        int mid=(l+r)>>1;",
			"        if (L<=mid){",
			"            Update(root<<1, l, mid, L, R, u);",
			"        }",
			"        if (mid+1<=R){",
			"            Update(root<<1|1, mid+1, r, L, R, u);",
			"        }",
			"    }",
			"    Pair Max(Pair x, Pair y){",
			"        if (x.second-y.second>eps){",
			"            return x;",
			"        }",
			"        if (y.second-x.second>eps){",
			"            return y;",
			"        }",
			"        if (x.first<y.first){",
			"            return x;",
			"        }else{",
			"            return y;",
			"        }",
			"    }",
			"    Pair Query(int root, int l, int r, int x){",
			"        if (x<l||r<x){",
			"            return {0, 0};",
			"        }",
			"        int mid=(l+r)>>1;",
			"        double ans=Calc(vis[root], x);",
			"        if (l==r){",
			"            return {vis[root], ans};",
			"        }",
			"        return Max({vis[root], ans}, Max(Query(root<<1, l, mid, x), Query(root<<1|1, mid+1, r, x)));",
			"    }",
			"}",
		],
	},
	"C++ Blocking_Add":{
		"prefix": "#Blocking_Add",
		"body": [
			"struct Blocking{",
			"    int siz;",
			"    int L[N], R[N];",
			"    int pos[N], sum[N], vis[N];",
			"    void Add(int l, int r, int w){",
			"        int x=pos[l], y=pos[r];",
			"        if (x==y){",
			"            for (int i=l; i<=r; i++){",
			"                a[i]+=w;",
			"            }",
			"            sum[x]+=(r-l+1)*w;  ",
			"        }else{",
			"            for (int i=l; i<=R[x]; i++){",
			"                a[i]+=w;",
			"            }",
			"            sum[x]+=(R[x]-l+1)*w;",
			"            for (int i=L[y]; i<=r; i++){",
			"                a[i]+=w;",
			"            }",
			"            sum[y]+=(r-L[y]+1)*w;",
			"            for (int i=x+1; i<=y-1; i++){",
			"                vis[i]+=w;",
			"            }",
			"        }",
			"    }",
			"    int Query(int l, int r){",
			"        int x=pos[l], y=pos[r];",
			"        int ans=0;",
			"        if (x==y){",
			"            for (int i=l; i<=r; i++){",
			"                ans+=a[i];",
			"            }",
			"            ans+=(r-l+1)*vis[x];",
			"        }else{",
			"            for (int i=l; i<=R[x]; i++){",
			"                ans+=a[i]+vis[x];",
			"            }",
			"            for (int i=L[y]; i<=r; i++){",
			"                ans+=a[i]+vis[y];",
			"            }",
			"            for (int i=x+1; i<=y-1; i++){",
			"                ans+=sum[i]+vis[i]*(R[i]-L[i]+1);",
			"            }",
			"        }",
			"        return ans;",
			"    }",
			"    void Init(){",
			"        siz=sqrt(n);",
			"        for (int i=1; i<=n; i++){",
			"            L[i]=(i-1)*siz+1;",
			"            R[i]=i*siz;",
			"        }",
			"        if (R[siz]<n){",
			"            siz++;",
			"            L[siz]=R[siz-1]+1;",
			"            R[siz]=n;",
			"        }",
			"        for (int i=1; i<=siz; i++){",
			"            for (int j=L[i]; j<=R[i]; j++){",
			"                pos[j]=i;",
			"                sum[i]+=a[j];",
			"            }",
			"        }",
			"    }",
			"}",
		],
	},
	"C++ Blocking_Mul":{
		"prefix": "#Blocking_Mul",
		"body": [
			"struct Blocking{",
		"    int siz;",
		"    int L[N], R[N];",
		"    int pos[N], sum[N];",
		"    int visa[N], vism[N];",
		"    void Down(int x){",
		"        for (int i=L[x]; i<=R[x]; i++){",
		"            a[i]=(a[i]*vism[x]+visa[x])%q;",
		"        }",
		"        visa[x]=0, vism[x]=1;",
		"    }",
		"    void Add(int l, int r, int w){",
		"        int x=pos[l], y=pos[r];",
		"        if (x==y){",
		"            Down(x);",
		"            for (int i=l; i<=r; i++){",
		"                a[i]=(a[i]+w)%q;",
		"            }",
		"            sum[x]=(sum[x]+(r-l+1)*w)%q;  ",
		"        }else{",
		"            Down(x), Down(y);",
		"            for (int i=l; i<=R[x]; i++){",
		"                a[i]=(a[i]+w)%q;",
		"            }",
		"            sum[x]=(sum[x]+(R[x]-l+1)*w)%q;",
		"            for (int i=L[y]; i<=r; i++){",
		"                a[i]=(a[i]+w)%q;",
		"            } ",
		"            sum[y]=(sum[y]+(r-L[y]+1)*w)%q;",
		"            for (int i=x+1; i<=y-1; i++){",
		"                visa[i]=(visa[i]+w)%q;",
		"                sum[i]=(sum[i]+(R[i]-L[i]+1)*w)%q;",
		"            }",
		"        }",
		"    }",
		"    void Mul(int l, int r, int w){",
		"        int x=pos[l], y=pos[r];",
		"        if (x==y){",
		"            Down(x);",
		"            for (int i=l; i<=r; i++){",
		"                sum[x]=(sum[x]+(a[i]*(w-1)))%q;",
		"                a[i]=(a[i]*w)%q;",
		"            }",
		"        }else{",
		"            Down(x), Down(y);",
		"            for (int i=l; i<=R[x]; i++){",
		"                sum[x]=(sum[x]+(a[i]*(w-1)))%q;",
		"                a[i]=(a[i]*w)%q;",
		"            }",
		"            for (int i=L[y]; i<=r; i++){",
		"                sum[y]=(sum[y]+(a[i]*(w-1)))%q;",
		"                a[i]=(a[i]*w)%q;",
		"            }",
		"            for (int i=x+1; i<=y-1; i++){",
		"                visa[i]=(visa[i]*w)%q;",
		"                vism[i]=(vism[i]*w)%q;",
		"                sum[i]=(sum[i]*w)%q;",
		"            }",
		"        }",
		"    }",
		"    int Query(int l, int r){",
		"        int x=pos[l], y=pos[r];",
		"        int ans=0;",
		"        if (x==y){",
		"            for (int i=l; i<=r; i++){",
		"                ans=(ans+a[i])%q;",
		"            }",
		"            ans=(ans*vism[x]+(r-l+1)*visa[x])%q;",
		"        }else{",
		"            for (int i=l; i<=R[x]; i++){",
		"                ans=(ans+a[i]*vism[x]+visa[x])%q;",
		"            }",
		"            for (int i=L[y]; i<=r; i++){",
		"                ans=(ans+a[i]*vism[y]+visa[y])%q;",
		"            }",
		"            for (int i=x+1; i<=y-1; i++){",
		"                ans=(ans+sum[i])%q;",
		"            }",
		"        }",
		"        return (ans+q)%q;",
		"    }",
		"    void Init(){",
		"        siz=sqrt(n);",
		"        for (int i=1; i<=n; i++){",
		"            L[i]=(i-1)*siz+1;",
		"            R[i]=i*siz;",
		"        }",
		"        if (R[siz]<n){",
		"            siz++;",
		"            L[siz]=R[siz-1]+1;",
		"            R[siz]=n;",
		"        }",
		"        for (int i=1; i<=siz; i++){",
		"            for (int j=L[i]; j<=R[i]; j++){",
		"                pos[j]=i;",
		"                sum[i]=(sum[i]+a[j])%q;",
		"            }",
		"            vism[i]=1;",
		"        }",
		"    }",
		"}",
		],
	},
	"C++ Trie_Tree":{
		"prefix": "#Trie_Tree",
		"body": [
			"struct Trie_Tree{",
			"    int num=1;",
			"    int ch[N][Z], sum[N];",
			"    bool ed[N];",
			"    void init(){",
			"        memset(ch, 0, sizeof(ch));",
			"        memset(ed, 0, sizeof(ed));",
			"        memset(sum, 0, sizeof(sum));",
			"        num=1;",
			"    }",
			"    int change(char c){",
			"        if ('A'<=c&&c<='Z'){",
			"            return c-'A';",
			"        }",
			"        if ('a'<=c&&c<='z'){",
			"            return c-'a'+26;",
			"        }",
			"        return c-'0'+52;",
			"    }",
			"    void add(string s){",
			"        int u=1, len=s.size();",
			"        for (int i=0; i<len; i++){",
			"            int c=change(s[i]);",
			"            if (!ch[u][c]){",
			"                ch[u][c]=++num;",
			"            }",
			"            u=ch[u][c];",
			"            sum[u]++;",
			"        }",
			"        ed[u]=1;",
			"    }",
			"    int find(string s){",
			"        int u=1, len=s.size();",
			"        for (int i=0; i<len; i++){",
			"            int c=change(s[i]);",
			"            if (!ch[u][c]){",
			"                return 0;",
			"            }",
			"            u=ch[u][c];",
			"        }",
			"        return sum[u];",
			"    }",
			"};",
		],
	},
	"C++ Sparse_Table":{
		"prefix": "#Sparse_Table",
		"body": [
			"struct Sparse_Table{",
			"    int dp[N][Z], lg[N];",
			"    Sparse_Table(){",
			"        lg[0]=-1;",
			"        for (int i=1; i<N; i++){",
			"            lg[i]=lg[i>>1]+1;",
			"        }",
			"    }",
			"    void Init(){",
			"        for (int j=1; j<=lg[n]; j++){",
			"            for (int i=1; i+(1<<j)-1<=n; i++){",
			"                dp[i][j]=max(dp[i][j-1], dp[i+(1<<(j-1))][j-1]);",
			"            }",
			"        }",
			"    }",
			"    int Query(int l, int r){",
			"        int len=lg[r-l+1];",
			"        return max(dp[l][len], dp[r-(1<<len)+1][len]);",
			"    }",
			"}",
		],
	},
	"C++ Treap":{
		"prefix": "#Treap",
		"body": [
			"struct Treap{",
			"    int num=0, root;",
			"    struct Node{",
			"        int l, r;",
			"        int vis, val;",
			"        int cnt, size;",
			"    }e[N<<1];",
			"    void Update(int x){",
			"        e[x].size=e[e[x].l].size+e[e[x].r].size+e[x].cnt;",
			"    }",
			"    void Zig(int &x){",
			"        int y=e[x].l;",
			"        e[x].l=e[y].r;",
			"        e[y].r=x, x=y;",
			"        Update(e[x].r);",
			"        Update(x);",
			"    }",
			"    void Zag(int &x){",
			"        int y=e[x].r;",
			"        e[x].r=e[y].l;",
			"        e[y].l=x, x=y;",
			"        Update(e[x].l);",
			"        Update(x);",
			"    }",
			"    int New(int val){",
			"        e[++num].val=val;",
			"        e[num].vis=rand();",
			"        e[num].size=1;",
			"        e[num].cnt=1;",
			"        return num;",
			"    }",
			"    void Insert(int &x, int val){",
			"        if (x==0){",
			"            x=New(val);",
			"            Update(x);",
			"            return ;",
			"        }",
			"        if (val==e[x].val){",
			"            e[x].cnt++;",
			"            Update(x);",
			"            return ;",
			"        }",
			"        if (val<e[x].val){",
			"            Insert(e[x].l, val);",
			"            if (e[x].vis<e[e[x].l].vis){",
			"                Zig(x);",
			"            }",
			"        }else{",
			"            Insert(e[x].r, val);",
			"            if (e[x].vis<e[e[x].r].vis){",
			"                Zag(x);",
			"            }",
			"        }",
			"        Update(x);",
			"    }",
			"    void Remove(int &x, int val){",
			"        if (x==0){",
			"            return ;",
			"        }",
			"        if (val==e[x].val){",
			"            if (e[x].cnt>1){",
			"                e[x].cnt--;",
			"                Update(x);",
			"                return ;",
			"            }",
			"            if (e[x].l||e[x].r){",
			"                if (e[x].r==0||e[e[x].l].vis>e[e[x].r].vis){",
			"                    Zig(x);",
			"                    Remove(e[x].r, val);",
			"                }else{",
			"                    Zag(x);",
			"                    Remove(e[x].l, val);",
			"                }",
			"            }else{",
			"                x=0;",
			"            }",
			"        }else{",
			"            if (val<e[x].val){",
			"                Remove(e[x].l, val);",
			"            }else{",
			"                Remove(e[x].r, val);",
			"            }",
			"        }",
			"        Update(x);",
			"    }",
			"    int Val_Rank(int x, int val){",
			"        if (x==0){",
			"            return 1;",
			"        }",
			"        if (val==e[x].val){",
			"            return e[e[x].l].size+1;",
			"        }",
			"        if (val<e[x].val){",
			"            return Val_Rank(e[x].l, val);",
			"        }else{",
			"            return Val_Rank(e[x].r, val)+e[e[x].l].size+e[x].cnt;",
			"        }",
			"    }",
			"    int Rank_Val(int x, int rank){",
			"        if (x==0){",
			"            return INF;",
			"        }",
			"        if (e[e[x].l].size>=rank){",
			"            return Rank_Val(e[x].l, rank);",
			"        }",
			"        if (e[e[x].l].size+e[x].cnt>=rank){",
			"            return e[x].val;",
			"        }",
			"        return Rank_Val(e[x].r, rank-e[e[x].l].size-e[x].cnt);",
			"    }",
			"    int Pre(int x, int val){",
			"        if (x==0){",
			"            return -INF;",
			"        }",
			"        if (e[x].val<val){",
			"            return max(e[x].val, Pre(e[x].r, val));",
			"        }else{",
			"            return Pre(e[x].l, val);",
			"        }",
			"    }",
			"    int Nxt(int x, int val){",
			"        if (x==0){",
			"            return INF;",
			"        }",
			"        if (e[x].val>val){",
			"            return min(e[x].val, Nxt(e[x].l, val));",
			"        }else{",
			"            return Nxt(e[x].r, val);",
			"        }",
			"    }",
			"};",
		],
	},
	"C++ Splay":{
		"prefix": "#Splay",
		"body": [
			"struct Splay{",
			"    int root, num;",
			"    struct Node{",
			"        int fa, val;",
			"        int size, cnt;",
			"        int son[2];",
			"    }e[N];",
			"    void Update(int x){",
			"        e[x].size=e[e[x].lson].size+e[e[x].rson].size+e[x].cnt;",
			"    }",
			"    bool Check(int x){",
			"        return x==e[e[x].fa].rson;",
			"    }",
			"    void Clear(int x){",
			"        e[x].fa=0, e[x].val=0;",
			"        e[x].size=0, e[x].cnt=0;",
			"        e[x].rson=0, e[x].lson=0;",
			"    }",
			"    void New(int x){",
			"        e[++num].val=x;",
			"        e[num].cnt++;",
			"    }",
			"    void Rotate(int x){",
			"        int y=e[x].fa, z=e[y].fa, to=Check(x);",
			"        e[y].son[to]=e[x].son[to^1];",
			"        if (e[x].son[to^1]){",
			"            e[e[x].son[to^1]].fa=y;",
			"        }",
			"        e[x].son[to^1]=y;",
			"        e[y].fa=x, e[x].fa=z;",
			"        if (z){",
			"            e[z].son[e[z].rson==y]=x;",
			"        }",
			"        Update(y);",
			"        Update(x);",
			"    }",
			"    void splay(int x){",
			"        for (int i=e[x].fa; i=e[x].fa, i; Rotate(x)){",
			"            if (e[i].fa){",
			"                Rotate(Check(x)==Check(i)?i:x);",
			"            }",
			"        }",
			"        root=x;",
			"    }",
			"    void Insert(int x){",
			"        if (!root){",
			"            New(x);",
			"            Update(num);",
			"            root=num;",
			"            return ;",
			"        }",
			"        int cur=root, last=0;",
			"        while (1){",
			"            if (e[cur].val==x){",
			"                e[cur].cnt++;",
			"                Update(cur);",
			"                Update(last);",
			"                splay(cur);",
			"                return ;",
			"            }",
			"            last=cur, cur=e[cur].son[x>e[cur].val];",
			"            if (!cur){",
			"                New(x);",
			"                e[num].fa=last;",
			"                e[last].son[x>e[last].val]=num;",
			"                Update(num);",
			"                Update(last);",
			"                splay(num);",
			"                return ;",
			"            }",
			"        }",
			"    }",
			"    int Pre(){",
			"        int cur=e[root].lson;",
			"        if (!cur){",
			"            return cur;",
			"        }",
			"        while (e[cur].rson){",
			"            cur=e[cur].rson;",
			"        }",
			"        splay(cur);",
			"        return cur;",
			"    }",
			"    int Nxt(){",
			"        int cur=e[root].rson;",
			"        if (!cur){",
			"            return cur;",
			"        }",
			"        while (e[cur].lson){",
			"            cur=e[cur].lson;",
			"        }",
			"        splay(cur);",
			"        return cur;",
			"    }",
			"    int Val_Rank(int x){",
			"        int ans=0, cur=root;",
			"        while (1){",
			"            if (x<e[cur].val){",
			"                cur=e[cur].lson;",
			"                continue;",
			"            }",
			"            ans+=e[e[cur].lson].size;",
			"            if (!cur){",
			"                return ans+1;",
			"            }",
			"            if (e[cur].val==x){",
			"                splay(cur);",
			"                return ans+1;",
			"            }",
			"            ans+=e[cur].cnt;",
			"            cur=e[cur].rson;",
			"        }",
			"    }",
			"    int Rank_Val(int x){",
			"        int cur=root;",
			"        while (1){",
			"            if (e[cur].lson&&x<=e[e[cur].lson].size){",
			"                cur=e[cur].lson;",
			"                continue;",
			"            }",
			"            x-=e[e[cur].lson].size+e[cur].cnt;",
			"            if (x<=0){",
			"                splay(cur);",
			"                return e[cur].val;",
			"            }",
			"            cur=e[cur].rson;",
			"        }",
			"    }",
			"    void Delete(int x){",
			"        Val_Rank(x);",
			"        if (e[root].cnt>1){",
			"            e[root].cnt--;",
			"            Update(root);",
			"            return ;",
			"        }",
			"        if (!e[root].lson&&!e[root].rson){",
			"            Clear(root);",
			"            root=0;",
			"            return ;",
			"        }",
			"        if (!e[root].lson){",
			"            int cur=root;",
			"            root=e[root].rson;",
			"            e[root].fa=0;",
			"            Clear(cur);",
			"            return ;",
			"        }",
			"        if (!e[root].rson){",
			"            int cur=root;",
			"            root=e[root].lson;",
			"            e[root].fa=0;",
			"            Clear(cur);",
			"            return ;",
			"        }",
			"        int cur=root;",
			"        int tmp=Pre();",
			"        e[e[cur].rson].fa=tmp;",
			"        e[tmp].rson=e[cur].rson;",
			"        Clear(cur);",
			"        Update(root);",
			"    }",
			"}",
		]
	},
	"C++ Pairing_Heap":{
		"prefix": "#Pairing_Heap",
		"body": [
			"struct Pairng_Heap{",
			"    struct Node{",
			"        int val, fa;",
			"        int to, nxt;",
			"        bool flag;",
			"    }e[N];",
			"    int Find(int x){",
			"        if (x==e[x].fa){",
			"            return x;",
			"        }",
			"        return e[x].fa=Find(e[x].fa);",
			"    }",
			"    int Merge(int x, int y){",
			"        if (x==0||y==0||x==y){",
			"            return x?x:y;",
			"        }",
			"        if (e[x].val>e[y].val||(e[x].val==e[y].val&&x>y)){",
			"            swap(x, y);",
			"        }",
			"        e[y].nxt=e[x].to;",
			"        e[x].to=y;",
			"        return e[y].fa=x;",
			"    }",
			"    int Merges(int x){",
			"        if (x==0){",
			"            return 0;",
			"        }",
			"        e[x].fa=x;",
			"        if (!e[x].nxt){",
			"            return x;",
			"        }",
			"        int y=e[x].nxt;",
			"        int z=e[y].nxt;",
			"        e[x].nxt=0, e[y].nxt=0;",
			"        e[y].fa=y;",
			"        return Merge(Merges(z), Merge(x, y));",
			"    }",
			"    int Query(int x){",
			"        if (e[x].flag){",
			"            int fx=Find(x);",
			"            e[fx].flag=0;",
			"            e[fx].fa=Merges(e[fx].to);",
			"            return e[fx].val;",
			"        }else{",
			"            return -1;",
			"        }",
			"    }",
			"    void Init(){",
			"        for (int i=1; i<=n; i++){",
			"            e[i].val=a[i];",
			"            e[i].fa=i, e[i].flag=1;",
			"        }",
			"    }",
			"}",
		],
	},
	"C++ Leftist_Tree":{
		"prefix": "#Leftist_Tree",
		"body": [
			"struct Leftist_Tree{",
			"    struct Node{",
			"        int dist, val;",
			"        int lson, rson;",
			"        int fa, flag;",
			"        int id;",
			"    }e[N];",
			"    int Find(int x){",
			"        if (e[x].fa==x){",
			"            return x;",
			"        }",
			"        return e[x].fa=Find(e[x].fa);",
			"    }",
			"    int &Rson(int x){",
			"        if (e[rson].dist<e[lson].dist){",
			"            return e[x].rson;",
			"        }else{",
			"            return e[x].lson;",
			"        }",
			"    }",
			"    int Merge(int x, int y){",
			"        if (!x||!y){",
			"            return x|y;",
			"        }",
			"        if (e[x].val>e[y].val||(e[x].val==e[y].val&&e[x].id>e[y].id)){",
			"            swap(x, y);",
			"        }",
			"        int &rson=Rson(x);",
			"        rson=Merge(rson, y);",
			"        e[x].dist=e[rson].dist+1;",
			"        return e[rson].fa=x;",
			"    }",
			"    void PushUp(int x){",
			"        if (!x){",
			"            return ;",
			"        }",
			"        if (e[x].dist!=e[Rson(x)].dist+1){",
			"            e[x].dist=e[Rson(x)].dist+1;",
			"            PushUp(e[x].fa);",
			"        }",
			"    }",
			"    void Merges(int x){",
			"        int y=Merge(e[x].lson, e[x].rson);",
			"        e[y].fa=e[x].fa;",
			"        if (e[e[x].fa].lson==x){",
			"            e[e[x].fa].lson=y;",
			"        }",
			"        if (e[e[x].fa].rson==x){",
			"            e[e[x].fa].rson=y;",
			"        }",
			"        PushUp(e[x].fa);",
			"        e[x].fa=y;",
			"        e[e[x].lson].fa=y;",
			"        e[e[x].rson].fa=y;",
			"    }",
			"    int Query(int x){",
			"        if (e[x].flag){",
			"            int fx=Find(x);",
			"            e[fx].flag=0;",
			"            Merges(fx);",
			"            return e[fx].val;",
			"        }else{",
			"            return -1;",
			"        }",
			"    }",
			"    void Init(){",
			"        e[0].dist=-1;",
			"        for (int i=1; i<=n; i++){",
			"            e[i].val=a[i], e[i].flag=1;",
			"            e[i].fa=i, e[i].id=i;",
			"        }",
			"    }",
			"}",
		]
	},
	"C++ Chain_Tree":{
		"prefix": "#Chain_Tree",
		"body": [
			"struct Chain_Tree{",
			"    Segment_Tree Seg;",
			"    int cnt, num=1, root;",
			"    int father[N], son[N], top[N];",
			"    int size[N], dep[N];",
			"    int seg[N], rev[N];",
			"    int head[N], to[N<<1], nxt[N<<1];",
			"    void Add(int u, int v){",
			"        to[++cnt]=v;",
			"        nxt[cnt]=head[u];",
			"        head[u]=cnt;",
			"    }",
			"    void Dfs1(int u, int fa){",
			"        father[u]=fa;",
			"        dep[u]=dep[fa]+1;",
			"        size[u]=1;",
			"        for (int i=head[u]; i; i=nxt[i]){",
			"            int v=to[i];",
			"            if (v==fa){",
			"                continue;",
			"            }",
			"            Dfs1(v, u);",
			"            size[u]+=size[v];",
			"            if (size[v]>size[son[u]]){",
			"                son[u]=v;",
			"            }",
			"        }",
			"    }",
			"    void Dfs2(int u, int fa){",
			"        if (son[u]){",
			"            int v=son[u];",
			"            top[v]=top[u];",
			"            seg[v]=++num;",
			"            rev[num]=v;",
			"            Dfs2(v, u);",
			"        }",
			"        for (int i=head[u]; i; i=nxt[i]){",
			"            int v=to[i];",
			"            if (v==fa||v==son[u]){",
			"                continue;",
			"            }",
			"            top[v]=v;",
			"            seg[v]=++num;",
			"            rev[num]=v;",
			"            Dfs2(v, u);",
			"        }",
			"    }",
			"    void Add_Line(int x, int y, int z){",
			"        int fx=top[x], fy=top[y];",
			"        while (fx!=fy){",
			"            if (dep[fx]<dep[fy]){",
			"                swap(fx, fy);",
			"                swap(x, y);",
			"            }",
			"            Seg.Add(1, 1, n, seg[fx], seg[x], z);",
			"            x=father[top[x]], fx=top[x];",
			"        }",
			"        if (dep[x]>dep[y]){",
			"            swap(x, y);",
			"        }",
			"        Seg.Add(1, 1, n, seg[x], seg[y], z);",
			"    }",
			"    void Add_Tree(int x, int z){",
			"        Seg.Add(1, 1, n, seg[x], seg[x]+size[x]-1, z);",
			"    }",
			"    int Query_Tree(int x){",
			"        return Seg.Query(1, 1, n, seg[x], seg[x]+size[x]-1);",
			"    }",
			"    int Query_Line(int x, int y){",
			"        int fx=top[x], fy=top[y], ans=0;",
			"        while (fx!=fy){",
			"            if (dep[fx]<dep[fy]){",
			"                swap(fx, fy);",
			"                swap(x, y);",
			"            }",
			"            ans=(ans+Seg.Query(1, 1, n, seg[fx], seg[x]))%q;",
			"            x=father[top[x]], fx=top[x];",
			"        }",
			"        if (dep[x]>dep[y]){",
			"            swap(x, y);",
			"        }",
			"        ans=(ans+Seg.Query(1, 1, n, seg[x], seg[y]))%q;",
			"        return ans;",
			"    }",
			"    void Init(){",
			"        root=r;",
			"        seg[root]=1;",
			"        top[root]=root;",
			"        rev[1]=root;",
			"        Dfs1(root, 0);",
			"        Dfs2(root, 0);",
			"        Seg.Build(1, 1, n, rev);",
			"    }",
			"}",
		],
	},
	"C++ Johnson":{
		"prefix": "#Johnson",
		"body": [
			"struct Johnson{",
			"    int cnt;",
			"    int head[N], to[M], nxt[M], val[M];",
			"    int dist[N], dis[N], tot[N];",
			"    bool vis[N];",
			"    struct Node{",
			"        int u, dis;",
			"        bool operator<(const Node &a)const{",
			"            return dis>a.dis;",
			"        }",
			"    };",
			"    void Add(int u, int v, int w){",
			"        to[++cnt]=v;",
			"        val[cnt]=w;",
			"        nxt[cnt]=head[u];",
			"        head[u]=cnt;",
			"    }",
			"    bool SPFA(int s){",
			"        queue<int> q;",
			"        memset(dist, 0x3f, sizeof(dist));",
			"        q.push(s);",
			"        dist[s]=0;",
			"        while (!q.empty()){",
			"            int u=q.front();",
			"            q.pop(), vis[u]=0;",
			"            for (int i=head[u]; i; i=nxt[i]){",
			"                int v=to[i], w=val[i];",
			"                if (dist[v]>dist[u]+w){",
			"                    dist[v]=dist[u]+w;",
			"                    if (!vis[v]){",
			"                        vis[v]=1;",
			"                        q.push(v);",
			"                        if (++tot[v]>n){",
			"                            return 0;",
			"                        }",
			"                    }",
			"                }",
			"            }",
			"        }",
			"        return 1;",
			"    }",
			"    void Dijkstra(int s){",
			"        priority_queue<Node> q;",
			"        memset(dis, 0x3f, sizeof(dis));",
			"        memset(vis, 0, sizeof(vis));",
			"        q.push({s, 0});",
			"        dis[s]=0;",
			"        while (!q.empty()){",
			"            int u=q.top().u;",
			"            q.pop();",
			"            if (vis[u]){",
			"                continue;",
			"            }",
			"            vis[u]=1;",
			"            for (int i=head[u]; i; i=nxt[i]){",
			"                int v=to[i], w=val[i];",
			"                if (dis[v]>dis[u]+w){",
			"                    dis[v]=dis[u]+w;",
			"                    if (!vis[v]){",
			"                        q.push({v, dis[v]});",
			"                    }",
			"                }",
			"            }",
			"        }",
			"    }",
			"    void Init(){",
			"        for (int u=1; u<=n; u++){",
			"            for (int i=head[u]; i; i=nxt[i]){",
			"                int v=to[i];",
			"                val[i]+=dist[u]-dist[v];",
			"            }",
			"        }",
			"    }",
			"};",
		]
	},
	"C++ Kruskal":{
		"prefix": "#Kruskal",
		"body": [
			"struct Kruskal{",
			"    Union_Find Uf;",
			"    int cnt;",
			"    struct Node{",
			"        int u, v, w;",
			"        bool operator<(const Node &a)const{",
			"            return w<a.w;",
			"        }",
			"    }e[M<<1];",
			"    void Add(int u, int v, int w){",
			"        e[++cnt].u=u;",
			"        e[cnt].v=v;",
			"        e[cnt].w=w;",
			"    }",
			"    void kruskal(){",
			"        sort(e+1, e+m+1);",
			"        for (int i=1; i<=m; i++){",
			"            int u=e[i].u, v=e[i].v, w=e[i].w;",
			"            int fu=Uf.Find(u), fv=Uf.Find(v);",
			"            if (fu!=fv){",
			"                Uf.fa[fu]=fv;",
			"                sum++;",
			"                ans+=w;",
			"            }",
			"        }",
			"    }",
			"};",
		],
	},
	"C++ Prim":{
		"prefix": "#Prim",
		"body": [
			"struct Prim{",
			"    int cnt;",
			"    int head[N], dist[N];",
			"    int to[M<<1], nxt[M<<1], val[M<<1];",
			"    bool vis[N];",
			"    struct Queue{",
			"        int u, dis;",
			"        bool operator<(const Queue &a)const{",
			"            return dis>a.dis;",
			"        }",
			"    };",
			"    void Add(int u, int v, int w){",
			"        to[++cnt]=v;",
			"        val[cnt]=w;",
			"        nxt[cnt]=head[u];",
			"        head[u]=cnt;",
			"    }",
			"    void Insert(int u, int v, int w){",
			"        Add(u, v, w);",
			"        Add(v, u, w);",
			"    }",
			"    void prim(int s){",
			"        memset(dist, 0x3f, sizeof(dist));",
			"        priority_queue<Queue> q;",
			"        q.push({s, 0});",
			"        dist[s]=0;",
			"        while (!q.empty()){",
			"            int u=q.top().u, dis=q.top().dis;",
			"            q.pop();",
			"            if (vis[u]){",
			"                continue;",
			"            }",
			"            vis[u]=1;",
			"            sum++;",
			"            ans+=dis;",
			"            for (int i=head[u]; i; i=nxt[i]){",
			"                int v=to[i], w=val[i];",
			"                if (dist[v]>w){",
			"                    dist[v]=w;",
			"                    q.push({v, dist[v]});",
			"                }  ",
			"            }",
			"        }",
			"    }",
			"};",
		],
	},
	"C++ Least_Common_Ancestors":{
		"prefix": "#Least_Common_Ancestors",
		"body": [
			"struct Least_Common_Ancestors{",
			"    int cnt;",
			"    int head[N], to[M<<1], nxt[M<<1];",
			"    int dep[N], dp[N][K];",
			"    void Add(int u, int v){",
			"        to[++cnt]=v;",
			"        nxt[cnt]=head[u];",
			"        head[u]=cnt;",
			"    }",
			"    void Dfs(int u, int fa){",
			"        for (int i=head[u]; i; i=nxt[i]){",
			"            int v=to[i];",
			"            if (v==fa){",
			"                continue;",
			"            }",
			"            dep[v]=dep[u]+1;",
			"            dp[v][0]=u;",
			"            for (int j=1; j<K; j++){",
			"                dp[v][j]=dp[dp[v][j-1]][j-1];",
			"            }",
			"            Dfs(v, u);",
			"        }",
			"    }",
			"    int lca(int x, int y){",
			"        if (dep[x]<dep[y]){",
			"            swap(x, y);",
			"        }",
			"        for (int i=K-1; i>=0; i--){",
			"            if (dep[dp[x][i]]>=dep[y]){",
			"                x=dp[x][i];",
			"            }",
			"        }",
			"        if (x==y){",
			"            return x;",
			"        }",
			"        for (int i=K-1; i>=0; i--){",
			"            if (dp[x][i]!=dp[y][i]){",
			"                x=dp[x][i], y=dp[y][i];",
			"            }",
			"        }",
			"        return dp[x][0];",
			"    }",
			"    Least_Common_Ancestors(){",
			"        dep[0]=-1;",
			"    }",
			"};",
		],
	},
	"C++ Binary_Graph":{
		"prefix":"#Binary_Graph",
		"body": [
			"int match[N];",
			"bool vis[N];",
			"bool dfs(int u){",
			"    for (int i=head[u]; i; i=nxt[i]){",
			"        int v=to[i];",
			"        if (!vis[v]){",
			"            vis[v]=1;",
			"            if (!match[v]||dfs(match[v])){",
			"                match[v]=u;",
			"                return 1;",
			"            }",
			"        }",
			"    }",
			"    return 0;",
			"}",
		],
	},
	"C++ Edmonds_Karp":{
		"prefix": "#Edmonds_Karp",
		"body": [
			"struct Edmonds_Karp{",
			"    int head[N], to[M], nxt[M], edge[M];",
			"    int idx[N][N], pre[N], dis[N], cnt=1;",
			"    bool vis[N];",
			"    void Add(int u, int v, int w){",
			"        to[++cnt]=v;",
			"        edge[cnt]=w;",
			"        nxt[cnt]=head[u];",
			"        head[u]=cnt;",
			"        idx[u][v]=cnt;",
			"    }",
			"    void Insert(int u, int v, int w){",
			"        if (!idx[u][v]){",
			"            Add(u, v, w);",
			"            Add(v, u, w);",
			"            edge[idx[v][u]]=0;",
			"        }else{",
			"            edge[idx[u][v]]+=w;",
			"        }",
			"    }",
			"    bool Bfs(){",
			"        memset(vis, 0, sizeof(vis));",
			"        queue<int> q;",
			"        q.push(s);",
			"        vis[s]=1, dis[s]=INF;",
			"        while (!q.empty()){",
			"            int u=q.front();",
			"            q.pop();",
			"            for (int i=head[u]; i; i=nxt[i]){",
			"                int v=to[i], w=edge[i];",
			"                if (vis[v]||w<=0){",
			"                    continue;",
			"                }",
			"                vis[v]=1, pre[v]=i;",
			"                dis[v]=min(dis[u], w);",
			"                q.push(v);",
			"                if (v==t){",
			"                    return 1;",
			"                }",
			"            }",
			"        }",
			"        return 0;",
			"    }",
			"    void Update(){",
			"        int x=t;",
			"        while (x!=s){",
			"            int last=pre[x];",
			"            edge[last]-=dis[t];",
			"            edge[last^1]+=dis[t];",
			"            x=to[last^1];",
			"        }",
			"        ans+=dis[t];",
			"    }",
			"};",
		]
	},
	"C++ Dinic":{
		"prefix": "#Dinic",
		"body": [
			"struct Dinic{",
			"    int cnt=1;",
			"    int head[N], to[M<<1], nxt[M<<1], flow[M<<1];",
			"    int dis[N], now[N];",
			"    void Add(int u, int v, int w){",
			"        to[++cnt]=v;",
			"        flow[cnt]=w;",
			"        nxt[cnt]=head[u];",
			"        head[u]=cnt;",
			"    }",
			"    void Insert(int u, int v, int w){",
			"        Add(u, v, w);",
			"        Add(v, u, 0);",
			"    }",
			"    bool Bfs(){",
			"        memset(dis, -1, sizeof(dis));",
			"        memcpy(now, head, sizeof(now));",
			"        queue<int> q;",
			"        q.push(s);",
			"        dis[s]=0;",
			"        while (!q.empty()){",
			"            int u=q.front();",
			"            q.pop();",
			"            for (int i=head[u]; i; i=nxt[i]){",
			"                int v=to[i], w=flow[i];",
			"                if (dis[v]==-1&&w>0){",
			"                    q.push(v);",
			"                    dis[v]=dis[u]+1;",
			"                }",
			"            }",
			"        }",
			"        if (dis[t]==-1){",
			"            return 0;",
			"        }",
			"        return 1;",
			"    }",
			"    int Dfs(int u, int sum){",
			"        if (u==t){",
			"            return sum;",
			"        }",
			"        int val, res=0;",
			"        for (int i=now[u]; i&&sum; i=nxt[i]){",
			"            int v=to[i], w=flow[i];",
			"            now[u]=i;",
			"            if (dis[v]==dis[u]+1&&w>0){",
			"                val=Dfs(v, min(sum, w));",
			"                if (val==0){",
			"                    dis[v]=-1;",
			"                }",
			"                flow[i]-=val;",
			"                flow[i^1]+=val;",
			"                res+=val, sum-=val;",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"};",
		],
	},
	"C++ Successive_Shortest_Path":{
		"prefix": "#Successive_Shortest_Path",
		"body": [
			"struct Successive_Shortest_Path{",
			"    int cnt=1;",
			"    int head[N], dist[N], ans[N], pre[N];",
			"    int to[M<<1], nxt[M<<1], flow[M<<1], dis[M<<1];",
			"    bool vis[N];",
			"    void Add(int u, int v, int f, int d){",
			"        to[++cnt]=v;",
			"        flow[cnt]=f;",
			"        dis[cnt]=d;",
			"        nxt[cnt]=head[u];",
			"        head[u]=cnt;",
			"    }",
			"    void Insert(int u, int v, int f, int d){",
			"        Add(u, v, f, d);",
			"        Add(v, u, 0, -d);",
			"    }",
			"    bool SPFA(){",
			"        memset(dist, 0x3f, sizeof(dist));",
			"        queue<int> q;",
			"        q.push(s);",
			"        dist[s]=0, ans[s]=INF;",
			"        while (!q.empty()){",
			"            int u=q.front();",
			"            q.pop();",
			"            vis[u]=0;",
			"            for (int i=head[u]; i; i=nxt[i]){",
			"                int v=to[i], w=dis[i], f=flow[i];",
			"                if (f>0&&dist[v]>dist[u]+w){",
			"                    dist[v]=dist[u]+w;",
			"                    ans[v]=min(ans[u], f);",
			"                    pre[v]=i;",
			"                    if (!vis[v]){",
			"                        vis[v]=1;",
			"                        q.push(v);",
			"                    }",
			"                }",
			"            }",
			"        }",
			"        if (dist[t]==0x3f3f3f3f){",
			"            return 0;",
			"        }",
			"        return 1;",
			"    }",
			"    int Update(){",
			"        int x=t;",
			"        while (x!=s){",
			"            int last=pre[x];",
			"            flow[last]-=ans[t];",
			"            flow[last^1]+=ans[t];",
			"            x=to[last^1];",
			"        }",
			"        return dist[t]*ans[t];",
			"    }",
			"};",
		],
	},
	"C++ Primal_Dual":{
		"prefix": "#Primal_Dual",
		"body": [
			"struct Primal_Dual{",
			"    int cnt=1;",
			"    int head[N], dis[N], dist[N], pre[N];",
			"    int to[M<<1], nxt[M<<1], flow[M<<1], cost[M<<1];",
			"    bool vis[N];",
			"    struct Node{",
			"        int u, dis;",
			"        bool operator<(const Node &a)const{",
			"            return dis>a.dis;",
			"        }",
			"    };",
			"    void Add(int u, int v, int f, int c){",
			"        to[++cnt]=v;",
			"        flow[cnt]=f;",
			"        cost[cnt]=c;",
			"        nxt[cnt]=head[u];",
			"        head[u]=cnt;",
			"    }",
			"    void Insert(int u, int v, int f, int c){",
			"        Add(u, v, f, c);",
			"        Add(v, u, 0, -c);",
			"    }",
			"    void SPFA(){",
			"        queue<int> q;",
			"        memset(dist, 0x3f, sizeof(dist));",
			"        q.push(s);",
			"        dist[s]=0;",
			"        while (!q.empty()){",
			"            int u=q.front();",
			"            q.pop(), vis[u]=0;",
			"            for (int i=head[u]; i; i=nxt[i]){",
			"                int v=to[i], f=flow[i], c=cost[i];",
			"                if (f&&dist[v]>dist[u]+c){",
			"                    dist[v]=dist[u]+c;",
			"                    if (!vis[v]){",
			"                        vis[v]=1;",
			"                        q.push(v);",
			"                    }",
			"                }",
			"            }",
			"        }",
			"    }",
			"    bool Dijkstra(){",
			"        priority_queue<Node> q;",
			"        memset(dis, 0x3f, sizeof(dis));",
			"        memset(vis, 0, sizeof(vis));",
			"        q.push({s, 0});",
			"        dis[s]=0;",
			"        while (!q.empty()){",
			"            int u=q.top().u;",
			"            q.pop();",
			"            if (vis[u]){",
			"                continue;",
			"            }",
			"            vis[u]=1;",
			"            for (int i=head[u]; i; i=nxt[i]){",
			"                int v=to[i], f=flow[i], c=cost[i]+dist[u]-dist[v];",
			"                if (f&&dis[v]>dis[u]+c){",
			"                    dis[v]=dis[u]+c;",
			"                    pre[v]=i;",
			"                    if (!vis[v]){",
			"                        q.push({v, dis[v]});",
			"                    }",
			"                }",
			"            }",
			"        }",
			"        if (dis[t]==0x3f3f3f3f){",
			"            return 0;",
			"        }",
			"        return 1;",
			"    }",
			"    int Update(){",
			"        for (int i=1; i<=n; i++){",
			"            dist[i]+=dis[i];",
			"        }",
			"        int x=t, minn=0x3f3f3f3f;",
			"        while (x!=s){",
			"            int last=pre[x];",
			"            minn=min(minn, flow[last]);",
			"            x=to[last^1];",
			"        }",
			"        x=t;",
			"        while (x!=s){",
			"            int last=pre[x];",
			"            flow[last]-=minn;",
			"            flow[last^1]+=minn;",
			"            x=to[last^1];",
			"        }",
			"        return minn*dist[t];",
			"    }",
			"};",
		],
	},
	"C++ Add":{
		"prefix": "#Add",
		"body": [
			"struct Add{",
			"    int len_a, len_b, len;",
			"    int a[N], b[N], sum[N];",
			"    void in(){",
			"        string s;",
			"        cin >> s;",
			"        len_a=s.size();",
			"        for (int i=1; i<=len_a; i++){",
			"            a[i]=s[len_a-i]-'0';",
			"        }",
			"        cin >> s;",
			"        len_b=s.size();",
			"        for (int i=1; i<=len_b; i++){",
			"            b[i]=s[len_b-i]-'0';",
			"        }",
			"    }",
			"    void add(){",
			"        int tmp=0;",
			"        len=max(len_a, len_b);",
			"        for (int i=1; i<=len; i++){",
			"            sum[i]=a[i]+b[i]+tmp;",
			"            tmp=sum[i]/10;",
			"            sum[i]%=10;",
			"        }",
			"        if (tmp){",
			"            sum[++len]=tmp;",
			"        }",
			"    }",
			"    void out(){",
			"        for (int i=len; i>=1; i--){",
			"            printf(\"%d\", sum[i]);",
			"        }",
			"    }",
			"}",
		],
	},
	"C++ Sub":{
		"prefix": "#Sub",
		"body": [
			"struct Sub{",
			"    int len_a, len_b, len;",
			"    int a[N], b[N], sum[N];",
			"    bool flag=0;",
			"    bool check(){",
			"        if (len_a==len_b){",
			"            for (int i=1; i<=len_a; i++){",
			"                if (a[i]<b[i]){",
			"                    return 1;",
			"                }",
			"            }",
			"            return 0;",
			"        }",
			"        if (len_a<len_b){",
			"            return 1;",
			"        }else{",
			"            return 0;",
			"        }",
			"    }",
			"    void in(){",
			"        string s;",
			"        cin >> s;",
			"        len_a=s.size();",
			"        for (int i=1; i<=len_a; i++){",
			"            a[i]=s[len_a-i]-'0';",
			"        }",
			"        cin >> s;",
			"        len_b=s.size();",
			"        for (int i=1; i<=len_b; i++){",
			"            b[i]=s[len_b-i]-'0';",
			"        }",
			"        if (check()){",
			"            for (int i=1; i<=len_a; i++){",
			"                sum[i]=a[i];",
			"            }",
			"            memset(a, 0, sizeof(a));",
			"            for (int i=1; i<=len_b; i++){",
			"                a[i]=b[i];",
			"            }",
			"            memset(b, 0, sizeof(b));",
			"            for (int i=1; i<=len_a; i++){",
			"                b[i]=sum[i];",
			"            }",
			"            swap(len_a, len_b);",
			"            flag=1;",
			"        }",
			"    }",
			"    void sub(){",
			"        int tmp=0;",
			"        len=max(len_a, len_b);",
			"        for (int i=1; i<=len; i++){",
			"            if (a[i]<b[i]){",
			"                a[i+1]--;",
			"                a[i]+=10;",
			"            }",
			"            sum[i]=a[i]-b[i];",
			"        }",
			"        while (!sum[len]&&len>1){",
			"            len--;",
			"        }",
			"    }",
			"    void out(){",
			"        if (flag){",
			"            printf(\"-\");",
			"        }",
			"        for (int i=len; i>=1; i--){",
			"            printf(\"%d\", sum[i]);",
			"        }",
			"    }",
			"}",
		],
	},
	"C++ Mul":{
		"prefix": "#Mul",
		"body": [
			"struct Mul{",
			"    int len_a, len_b, len;",
			"    int a[N], b[N], sum[N<<1];",
			"    bool check(){",
			"        if (len_a==len_b){",
			"            for (int i=1; i<=len_a; i++){",
			"                if (a[i]<b[i]){",
			"                    return 1;",
			"                }",
			"            }",
			"            return 0;",
			"        }",
			"        if (len_a<len_b){",
			"            return 1;",
			"        }else{",
			"            return 0;",
			"        }",
			"    }",
			"    void in(){",
			"        string s;",
			"        cin >> s;",
			"        len_a=s.size();",
			"        for (int i=1; i<=len_a; i++){",
			"            a[i]=s[len_a-i]-'0';",
			"        }",
			"        cin >> s;",
			"        len_b=s.size();",
			"        for (int i=1; i<=len_b; i++){",
			"            b[i]=s[len_b-i]-'0';",
			"        }",
			"    }",
			"    void mul(){",
			"        int tmp=0;",
			"        len=len_a+len_b;",
			"        for (int i=1; i<=len_a; i++){",
			"            for (int j=1; j<=len_b; j++){",
			"                tmp=(a[i]*b[j]+sum[i+j-1])/10;",
			"                sum[i+j-1]=(a[i]*b[j]+sum[i+j-1])%10;",
			"                sum[i+j]+=tmp;",
			"            }",
			"        }",
			"        while (!sum[len]&&len>1){",
			"            len--;",
			"        }",
			"    }",
			"    void out(){",
			"        for (int i=len; i>=1; i--){",
			"            printf(\"%d\", sum[i]);",
			"        }",
			"    }",
			"}",
		],
	},
	"C++ Div":{
		"prefix": "#Div",
		"body": [
			"struct Sub{",
			"    int len, b, start=1;",
			"    int a[N], sum[N];",
			"    void in(){",
			"        string s;",
			"        cin >> s >> b;",
			"        len=s.size();",
			"        for (int i=1; i<=len; i++){",
			"            a[i]=s[i-1]-'0';",
			"        }",
			"    }",
			"    void div(){",
			"        int tmp=0;",
			"        for (int i=1; i<=len; i++){",
			"            sum[i]=(tmp*10+a[i])/b;",
			"            tmp=(tmp*10+a[i])%b;",
			"        }",
			"        while (!sum[start]&&start<len){",
			"            start++;",
			"        }",
			"    }",
			"    void out(){",
			"        for (int i=start; i<=len; i++){",
			"            printf(\"%d\", sum[i]);",
			"        }",
			"    }",
			"}",
		],
	},
}
