{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	"C++ Template":{
		"prefix": "#file",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"int main(){",
			"    // freopen(\"std.in\", \"r\", stdin);",
			"    // freopen(\"std.out\", \"w\", stdout);",
			"    ios::sync_with_stdio(0);",
			"    cin.tie();",
			"",
			"    return 0;",
			"}",
		],
	},
	"C++ Freopen":{
		"prefix": "#freopen",
		"body": [
			"freopen(\"std.in\", \"r\", stdin);",
			"freopen(\"std.out\", \"w\", stdout);",
		],
	},
	"C++ Binary Graph":{
		"prefix":"#bingraph",
		"body": [
			"int match[N];",
			"bool vis[N];",
			"bool dfs(int u){",
			"    for (int i=head[u]; i; i=nxt[i]){",
			"        int v=to[i];",
			"        if (!vis[v]){",
			"            vis[v]=1;",
			"            if (!match[v]||dfs(match[v])){",
			"                match[v]=u;",
			"                return 1;",
			"            }",
			"        }",
			"    }",
			"    return 0;",
			"}",
		],
	},
	"C++ Graph":{
		"prefix": "#graph",
		"body": [
			"int cnt;",
			"int head[N], to[N<<1], nxt[N<<1];",
			"void add(int u, int v){",
			"    to[++cnt]=v;",
			"    nxt[cnt]=head[u];",
			"    head[u]=cnt;",
			"}",
		],
	},
	"C++ Chain_Tree":{
		"prefix": "#chain_tree",
		"body": [
			"struct Chain_Tree{",
			"    int cnt, num=1;",
			"    int head[N], to[N<<1], nxt[N<<1];",
			"    int father[N], dep[N], size[N], son[N];",
			"    int top[N], dfn[N], rev[N];",
			"    void add(int u, int v){",
			"        to[++cnt]=v;",
			"        nxt[cnt]=head[u];",
			"        head[u]=cnt;",
			"    }",
			"    void dfs1(int u, int fa){",
			"        father[u]=fa;",
			"        size[u]=1;",
			"        dep[u]=dep[fa]+1;",
			"        for (int i=head[u]; i; i=nxt[i]){",
			"            int v=to[i];",
			"            if (v!=fa){",
			"                dfs(v, u);",
			"                size[u]+=size[v];",
			"                if (size[v]>size[son[u]]){",
			"                    son[u]=v;",
			"                }",
			"            }",
			"        }",
			"    }",
			"    void dfs2(int u, int fa){",
			"        if (son[u]){",
			"            dfn[son[u]]=++num;",
			"            top[son[u]]=top[u];",
			"            rev[num]=son[u];",
			"            dfs2(son[u], u);",
			"        }",
			"        for (int i=head[u]; i; i=nxt[i]){",
			"            int v=to[i];",
			"            if (!dfn[v]){",
			"                dfn[v]=++num;",
			"                top[v]=v;",
			"                rev[num]=v;",
			"                dfs2(v, u);",
			"            }",
			"        }",
			"    }",
			"    void init(){",
			"        dfn[1]=top[1]=rev[1]=1;",
			"        dfs1(1, 0);",
			"        dfs2(1, 0);",
			"    }",
			"};",
		],
	},
	"C++ Segment_Tree":{
		"prefix": "#segment_tree",
		"body": [
			"struct Segment_Tree{",
			"    int a[N];",
			"    struct Node{",
			"        long long sum, vis;",
			"    }e[N<<2];",
			"    void build(int x, int l, int r){",
			"        if (l==r){",
			"            e[x].sum=a[l];",
			"            return ;",
			"        }",
			"        int mid=(l+r)>>1;",
			"        build(x<<1, l, mid);",
			"        build(x<<1|1, mid+1, r);",
			"        e[x].sum=e[x<<1].sum+e[x<<1|1].sum;",
			"    }",
			"    void down(int x, int l, int r){",
			"        e[x<<1].vis+=e[x].vis;",
			"        e[x<<1|1].vis+=e[x].vis;",
			"        int mid=(l+r)>>1;",
			"        e[x<<1].sum+=(mid-l+1)*e[x].vis;",
			"        e[x<<1|1].sum+=(r-mid)*e[x].vis;",
			"        e[x].vis=0;",
			"    }",
			"    void add(int x, int l, int r, int L, int R, int w){",
			"        if (L<=l&&r<=R){",
			"            e[x].vis+=w;",
			"            e[x].sum+=(r-l+1)*w;",
			"            return ;",
			"        }",
			"        down(x, l, r);",
			"        int mid=(l+r)>>1;",
			"        if (L<=mid){",
			"            add(x<<1, l, mid, L, R, w);",
			"        }",
			"        if (mid+1<=R){",
			"            add(x<<1|1, mid+1, r, L, R, w);",
			"        }",
			"        e[x].sum=e[x<<1].sum+e[x<<1|1].sum;",
			"    }",
			"    long long sum(int x, int l, int r, int L, int R){",
			"        if (L<=l&&r<=R){",
			"            return e[x].sum;",
			"        }",
			"        down(x, l, r);",
			"        int mid=(l+r)>>1;",
			"        long long ans=0;",
			"        if (L<=mid){",
			"            ans+=sum(x<<1, l, mid, L, R);",
			"        }",
			"        if (mid+1<=R){",
			"            ans+=sum(x<<1|1, mid+1, r, L, R);",
			"        }",
			"        return ans;",
			"    }",
			"};",
		],
	},
	"C++ Binary_Indexed_Tree":{
		"prefix": "#binary_indexed_tree",
		"body": [
			"struct Binary_Indexed_Tree{",
			"    int num[N];",
			"    int lowbit(int x){",
			"        return x&-x;",
			"    }",
			"    void add(int x, int y){",
			"        for (int i=x; i<=n; i+=lowbit(i)){",
			"            num[i]+=y;",
			"        }",
			"    }",
			"    int sum(int x){",
			"        int ans=0;",
			"        for (int i=x; i>=1; i-=lowbit(i)){",
			"            ans+=num[i];",
			"        }",
			"        return ans;",
			"    }",
			"};",
		],
	},
	"C++ Trie_Tree":{
		"prefix": "#trie_tree",
		"body": [
			"struct Trie_Tree{",
			"    int num=1;",
			"    int ch[N][Z], sum[N];",
			"    bool ed[N];",
			"    int change(char c){",
			"        if ('A'<=c&&c<='Z'){",
			"            return c-'A';",
			"        }",
			"        if ('a'<=c&&c<='z'){",
			"            return c-'a'+26;",
			"        }",
			"        return c-'0'+52;",
			"    }",
			"    void add(string s){",
			"        int u=1, len=s.size();",
			"        for (int i=0; i<len; i++){",
			"            int c=change(s[i]);",
			"            if (!ch[u][c]){",
			"                ch[u][c]=++num;",
			"            }",
			"            u=ch[u][c];",
			"            sum[u]++;",
			"        }",
			"        ed[u]=1;",
			"    }",
			"    int find(string s){",
			"        int u=1, len=s.size();",
			"        for (int i=0; i<len; i++){",
			"            int c=change(s[i]);",
			"            if (!ch[u][c]){",
			"                return 0;",
			"            }",
			"            u=ch[u][c];",
			"        }",
			"        return sum[u];",
			"    }",
			"    void init(){",
			"        memset(ch, 0, sizeof(ch));",
			"        memset(ed, 0, sizeof(ed));",
			"        memset(sum, 0, sizeof(sum));",
			"        num=1;",
			"    }",
			"}",
		],
	},
}