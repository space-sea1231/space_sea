{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	"C++ Template":{
		"prefix": "#file",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"int main(){",
			"    // freopen(\"std.in\", \"r\", stdin);",
			"    // freopen(\"std.out\", \"w\", stdout);",
			"    ios::sync_with_stdio(0);",
			"    cin.tie();",
			"",
			"    return 0;",
			"}",
		],
	},
	"C++ Freopen":{
		"prefix": "#freopen",
		"body": [
			"freopen(\"std.in\", \"r\", stdin);",
			"freopen(\"std.out\", \"w\", stdout);",
		],
	},
	"C++ Binary Graph":{
		"prefix":"#bingraph",
		"body": [
			"int match[N];",
			"bool vis[N];",
			"bool dfs(int u){",
			"    for (int i=head[u]; i; i=nxt[i]){",
			"        int v=to[i];",
			"        if (!vis[v]){",
			"            vis[v]=1;",
			"            if (!match[v]||dfs(match[v])){",
			"                match[v]=u;",
			"                return 1;",
			"            }",
			"        }",
			"    }",
			"    return 0;",
			"}",
		],
	},
	"C++ Graph":{
		"prefix": "#graph",
		"body": [
			"int cnt;",
			"int head[N], to[N<<1], nxt[N<<1];",
			"void add(int u, int v){",
			"    to[++cnt]=v;",
			"    nxt[cnt]=head[u];",
			"    head[u]=cnt;",
			"}",
		],
	},
	"C++ Chain_Tree":{
		"prefix": "#chain_tree",
		"body": [
			"struct Chain_Tree{",
			"    int cnt, num=1;",
			"    int head[N], to[N<<1], nxt[N<<1];",
			"    int father[N], dep[N], size[N], son[N];",
			"    int top[N], dfn[N], rev[N];",
			"    void add(int u, int v){",
			"        to[++cnt]=v;",
			"        nxt[cnt]=head[u];",
			"        head[u]=cnt;",
			"    }",
			"    void dfs1(int u, int fa){",
			"        father[u]=fa;",
			"        size[u]=1;",
			"        dep[u]=dep[fa]+1;",
			"        for (int i=head[u]; i; i=nxt[i]){",
			"            int v=to[i];",
			"            if (v!=fa){",
			"                dfs(v, u);",
			"                size[u]+=size[v];",
			"                if (size[v]>size[son[u]]){",
			"                    son[u]=v;",
			"                }",
			"            }",
			"        }",
			"    }",
			"    void dfs2(int u, int fa){",
			"        if (son[u]){",
			"            dfn[son[u]]=++num;",
			"            top[son[u]]=top[u];",
			"            rev[num]=son[u];",
			"            dfs2(son[u], u);",
			"        }",
			"        for (int i=head[u]; i; i=nxt[i]){",
			"            int v=to[i];",
			"            if (!dfn[v]){",
			"                dfn[v]=++num;",
			"                top[v]=v;",
			"                rev[num]=v;",
			"                dfs2(v, u);",
			"            }",
			"        }",
			"    }",
			"    void init(){",
			"        dfn[1]=top[1]=rev[1]=1;",
			"        dfs1(1, 0);",
			"        dfs2(1, 0);",
			"    }",
			"};",
		],
	},
	"C++ Segment Tree":{
		"prefix": "#segment_tree_add",
		"body": [
			"struct Segment_Tree{",
			"    struct Node{",
			"        int sum, vis;",
			"    }e[N<<2];",
			"    void Build(int x, int l, int r){",
			"        if (l==r){",
			"            e[x].sum=a[l];",
			"            return ;",
			"        }",
			"        int mid=(l+r)>>1;",
			"        Build(x<<1, l, mid);",
			"        Build(x<<1|1, mid+1, r);",
			"        e[x].sum=e[x<<1].sum+e[x<<1|1].sum;",
			"    }",
			"    void Down(int x, int l, int r){",
			"        int mid=(l+r)>>1;",
			"        e[x<<1].vis+=e[x].vis;",
			"        e[x<<1|1].vis+=e[x].vis;",
			"        e[x<<1].sum+=(mid-l+1)*e[x].vis;",
			"        e[x<<1|1].sum+=(r-mid)*e[x].vis;",
			"        e[x].vis=0;",
			"    }",
			"    void Add(int x, int l, int r, int L, int R, int w){",
			"        if (L<=l&&r<=R){",
			"            e[x].vis+=w;",
			"            e[x].sum+=(r-l+1)*w;",
			"            return ;",
			"        }",
			"        ",
			"        Down(x, l, r);",
			"        int mid=(l+r)>>1;",
			"        if (L<=mid){",
			"            Add(x<<1, l, mid, L, R, w);",
			"        }",
			"        if (mid+1<=R){",
			"            Add(x<<1|1, mid+1, r, L, R, w);",
			"        }",
			"        e[x].sum=e[x<<1].sum+e[x<<1|1].sum;",
			"    }",
			"    int Query(int x, int l, int r, int L, int R){",
			"        if (L<=l&&r<=R){",
			"            return e[x].sum;",
			"        }",
			"        Down(x, l, r);",
			"        int mid=(l+r)>>1, ans=0;",
			"        if (L<=mid){",
			"            ans+=Query(x<<1, l, mid, L, R);",
			"        }",
			"        if (mid+1<=R){",
			"            ans+=Query(x<<1|1, mid+1, r, L, R);",
			"        }",
			"        return ans;",
			"    }",
			"}",
		],
	},
	"C++ Segment_Tree_Mul":{
		"prefix": "#segment_tree_mul",
		"body": [
			"struct Segment_Tree{",
			"    struct Node{",
			"        int sum, vis_add, vis_mul;",
			"    }e[N<<1];",
			"    void Build(int x, int l, int r){",
			"        int mid=(l+r)>>1;",
			"        e[x].vis_mul=1;",
			"        if (l==r){",
			"            e[x].sum=a[l];",
			"            return;",
			"        }",
			"        Build(x<<1, l, mid);",
			"        Build(x<<1|1, mid+1, r);",
			"        e[x].sum+=e[x<<1|1].sum;",
			"    }",
			"    void Down(int x, int l, int r){",
			"        int mid=(l+r)>>1;",
			"        e[x<<1].sum=e[x<<1].sum*e[x].vis_mul+(mid-l+1)*e[x].vis_add;",
			"        e[x<<1|1].sum=e[x<<1|1].sum*e[x].vis_mul+(r-mid)*e[x].vis_add;",
			"        e[x<<1].vis_add=e[x<<1].vis_add*e[x].vis_mul+e[x].vis_add;",
			"        e[x<<1|1].vis_add=e[x<<1|1].vis_add*e[x].vis_mul+e[x].vis_add;",
			"        e[x<<1].vis_mul*=e[x].vis_mul;",
			"        e[x<<1|1].vis_mul*=e[x].vis_mul;",
			"        e[x].vis_add=0, e[x].vis_mul=1;",
			"    }",
			"    void Mul(int x, int l, int r, int L, int R, int w){",
			"        if (L<=l&&r<=R){",
			"            e[x].vis_add=e[x].vis_add*w;",
			"            e[x].vis_mul=e[x].vis_mul*w;",
			"            e[x].sum=e[x].sum*w;",
			"            return;",
			"        }",
			"        Down(x, l, r);",
			"        int mid=(l+r)>>1;",
			"        if (L<=mid){",
			"            Mul(x<<1, l, mid, L, R, w);",
			"        }",
			"        if (mid+1<=R){",
			"            Mul(x<<1|1, mid+1, r, L, R, w);",
			"        }",
			"        e[x].sum=e[x<<1].sum+e[x<<1|1].sum;",
			"    }",
			"    void Add(int x, int l, int r, int L, int R, int w){",
			"        if (L<=l&&r<=R){",
			"            e[x].vis_add+=w;",
			"            e[x].sum+=(r-l+1)*w;",
			"            return;",
			"        }",
			"        Down(x, l, r);",
			"        int mid=(l+r)>>1;",
			"        if (L<=mid){",
			"            Add(x<<1, l, mid, L, R, w);",
			"        }",
			"        if (mid+1<=R){",
			"            Add(x<<1|1, mid+1, r, L, R, w);",
			"        }",
			"        e[x].sum=e[x<<1].sum+e[x<<1|1].sum;",
			"    }",
			"    int Query(int x, int l, int r, int L, int R){",
			"        if (L<=l&&r<=R){",
			"            return e[x].sum;",
			"        }",
			"        Down(x, l, r);",
			"        int mid=(l+r)>>1, ans=0;",
			"        if (L<=mid){",
			"            ans+=Query(x<<1, l, mid, L, R);",
			"        }",
			"        if (mid+1<=R){",
			"            ans+=Query(x<<1|1, mid+1, r, L, R);",
			"        }",
			"        return ans;",
			"    }",
			"};",
		],
	},
	"C++ Binary_Indexed_Tree":{
		"prefix": "#binary_indexed_tree",
		"body": [
			"struct Binary_Indexed_Tree{",
			"    int num[N];",
			"    int lowbit(int x){",
			"        return x&-x;",
			"    }",
			"    void add(int x, int y){",
			"        for (int i=x; i<=n; i+=lowbit(i)){",
			"            num[i]+=y;",
			"        }",
			"    }",
			"    int sum(int x){",
			"        int ans=0;",
			"        for (int i=x; i>=1; i-=lowbit(i)){",
			"            ans+=num[i];",
			"        }",
			"        return ans;",
			"    }",
			"};",
		],
	},
	"C++ Trie_Tree":{
		"prefix": "#trie_tree",
		"body": [
			"struct Trie_Tree{",
			"    int num=1;",
			"    int ch[N][Z], sum[N];",
			"    bool ed[N];",
			"    void init(){",
			"        memset(ch, 0, sizeof(ch));",
			"        memset(ed, 0, sizeof(ed));",
			"        memset(sum, 0, sizeof(sum));",
			"        num=1;",
			"    }",
			"    int change(char c){",
			"        if ('A'<=c&&c<='Z'){",
			"            return c-'A';",
			"        }",
			"        if ('a'<=c&&c<='z'){",
			"            return c-'a'+26;",
			"        }",
			"        return c-'0'+52;",
			"    }",
			"    void add(string s){",
			"        int u=1, len=s.size();",
			"        for (int i=0; i<len; i++){",
			"            int c=change(s[i]);",
			"            if (!ch[u][c]){",
			"                ch[u][c]=++num;",
			"            }",
			"            u=ch[u][c];",
			"            sum[u]++;",
			"        }",
			"        ed[u]=1;",
			"    }",
			"    int find(string s){",
			"        int u=1, len=s.size();",
			"        for (int i=0; i<len; i++){",
			"            int c=change(s[i]);",
			"            if (!ch[u][c]){",
			"                return 0;",
			"            }",
			"            u=ch[u][c];",
			"        }",
			"        return sum[u];",
			"    }",
			"};",
		],
	},
	"C++ Treap":{
		"prefix": "#treap",
		"body": [
			"struct Treap{",
			"    int num=0, root;",
			"    struct Node{",
			"        int l, r;",
			"        int vis, val;",
			"        int cnt, size;",
			"    }e[N<<1];",
			"    void Update(int x){",
			"        e[x].size=e[e[x].l].size+e[e[x].r].size+e[x].cnt;",
			"    }",
			"    void Zig(int &x){",
			"        int y=e[x].l;",
			"        e[x].l=e[y].r;",
			"        e[y].r=x, x=y;",
			"        Update(e[x].r);",
			"        Update(x);",
			"    }",
			"    void Zag(int &x){",
			"        int y=e[x].r;",
			"        e[x].r=e[y].l;",
			"        e[y].l=x, x=y;",
			"        Update(e[x].l);",
			"        Update(x);",
			"    }",
			"    int New(int val){",
			"        e[++num].val=val;",
			"        e[num].vis=rand();",
			"        e[num].size=1;",
			"        e[num].cnt=1;",
			"        return num;",
			"    }",
			"    void Insert(int &x, int val){",
			"        if (x==0){",
			"            x=New(val);",
			"            Update(x);",
			"            return ;",
			"        }",
			"        if (val==e[x].val){",
			"            e[x].cnt++;",
			"            Update(x);",
			"            return ;",
			"        }",
			"        if (val<e[x].val){",
			"            Insert(e[x].l, val);",
			"            if (e[x].vis<e[e[x].l].vis){",
			"                Zig(x);",
			"            }",
			"        }else{",
			"            Insert(e[x].r, val);",
			"            if (e[x].vis<e[e[x].r].vis){",
			"                Zag(x);",
			"            }",
			"        }",
			"        Update(x);",
			"    }",
			"    void Remove(int &x, int val){",
			"        if (x==0){",
			"            return ;",
			"        }",
			"        if (val==e[x].val){",
			"            if (e[x].cnt>1){",
			"                e[x].cnt--;",
			"                Update(x);",
			"                return ;",
			"            }",
			"            if (e[x].l||e[x].r){",
			"                if (e[x].r==0||e[e[x].l].vis>e[e[x].r].vis){",
			"                    Zig(x);",
			"                    Remove(e[x].r, val);",
			"                }else{",
			"                    Zag(x);",
			"                    Remove(e[x].l, val);",
			"                }",
			"            }else{",
			"                x=0;",
			"            }",
			"        }else{",
			"            if (val<e[x].val){",
			"                Remove(e[x].l, val);",
			"            }else{",
			"                Remove(e[x].r, val);",
			"            }",
			"        }",
			"        Update(x);",
			"    }",
			"    int Val_Rank(int x, int val){",
			"        if (x==0){",
			"            return 1;",
			"        }",
			"        if (val==e[x].val){",
			"            return e[e[x].l].size+1;",
			"        }",
			"        if (val<e[x].val){",
			"            return Val_Rank(e[x].l, val);",
			"        }else{",
			"            return Val_Rank(e[x].r, val)+e[e[x].l].size+e[x].cnt;",
			"        }",
			"    }",
			"    int Rank_Val(int x, int rank){",
			"        if (x==0){",
			"            return INF;",
			"        }",
			"        if (e[e[x].l].size>=rank){",
			"            return Rank_Val(e[x].l, rank);",
			"        }",
			"        if (e[e[x].l].size+e[x].cnt>=rank){",
			"            return e[x].val;",
			"        }",
			"        return Rank_Val(e[x].r, rank-e[e[x].l].size-e[x].cnt);",
			"    }",
			"    int Pre(int x, int val){",
			"        if (x==0){",
			"            return -INF;",
			"        }",
			"        if (e[x].val<val){",
			"            return max(e[x].val, Pre(e[x].r, val));",
			"        }else{",
			"            return Pre(e[x].l, val);",
			"        }",
			"    }",
			"    int Nxt(int x, int val){",
			"        if (x==0){",
			"            return INF;",
			"        }",
			"        if (e[x].val>val){",
			"            return min(e[x].val, Nxt(e[x].l, val));",
			"        }else{",
			"            return Nxt(e[x].r, val);",
			"        }",
			"    }",
			"};",
		],
	},
	"C++ Blocking":{
		"prefix": "#blocking",
		"body": [
			"struct Blocking{",
			"    int siz;",
			"    int L[N], R[N];",
			"    int pos[N], sum[N], vis[N];",
			"    void Add(int x, int y, int z){",
			"        int x=pos[x], y=pos[y];",
			"        if (x==y){",
			"            for (int i=x; i<=y; i++){",
			"                a[i]+=z;",
			"            }",
			"            sum[x]+=(y-x+1)*z;  ",
			"        }else{",
			"            for (int i=x+1; i<=y-1; i++){",
			"                vis[i]+=z;",
			"            }",
			"            for (int i=x; i<=R[x]; i++){",
			"                a[i]+=z;",
			"            }",
			"            sum[x]+=(R[x]-x+1)*z;",
			"            for (int i=L[y]; i<=y; i++){",
			"                a[i]+=z;",
			"            }",
			"            sum[y]+=(y-L[y]+1)*z;",
			"        }",
			"    }",
			"    int Query(int l, int r){",
			"        int x=pos[l], y=pos[r];",
			"        int ans=0;",
			"        if (x==y){",
			"            for (int i=l; i<=r; i++){",
			"                ans+=a[i];",
			"            }",
			"            ans+=(r-l+1)*vis[x];",
			"        }else{",
			"            for (int i=l; i<=R[x]; i++){",
			"                ans+=a[i]+vis[x];",
			"            }",
			"            for (int i=L[y]; i<=r; i++){",
			"                ans+=a[i]+vis[y];",
			"            }",
			"            for (int i=x+1; i<=y-1; i++){",
			"                ans+=sum[i]+vis[i]*(R[i]-L[i]+1);",
			"            }",
			"        }",
			"        return ans;",
			"    }",
			"    void Init(){",
			"        siz=sqrt(n);",
			"        for (int i=1; i<=n; i++){",
			"            L[i]=(i-1)*siz+1;",
			"            R[i]=i*siz;",
			"        }",
			"        if (R[siz]<n){",
			"            siz++;",
			"            L[siz]=R[siz-1]+1;",
			"            R[siz]=n;",
			"        }",
			"        for (int i=1; i<=siz; i++){",
			"            for (int j=L[i]; j<=R[i]; j++){",
			"                pos[j]=i;",
			"                sum[i]+=a[j];",
			"            }",
			"        }",
			"    }",
			"}",
		],
	},
	"C++ Sparse_Table":{
		"prefix": "#spares_table",
		"body": [
			"struct Sparse_Table{",
			"    int dp[N][Z], lg[N];",
			"    Sparse_Table(){",
			"        lg[0]=-1;",
			"        for (int i=1; i<N; i++){",
			"            lg[i]=lg[i>>1]+1;",
			"        }",
			"    }",
			"    void Init(){",
			"        for (int j=1; j<=lg[n]; j++){",
			"            for (int i=1; i+(1<<j)-1<=n; i++){",
			"                dp[i][j]=max(dp[i][j-1], dp[i+(1<<(j-1))][j-1]);",
			"            }",
			"        }",
			"    }",
			"    int Query(int l, int r){",
			"        int len=lg[r-l+1];",
			"        return max(dp[l][len], dp[r-(1<<len)+1][len]);",
			"    }",
			"}",
		],
	},
	"C++ Add":{
		"prefix": "#add",
		"body": [
			"struct Add{",
			"    int len_a, len_b, len;",
			"    int a[N], b[N], sum[N];",
			"    void in(){",
			"        string s;",
			"        cin >> s;",
			"        len_a=s.size();",
			"        for (int i=1; i<=len_a; i++){",
			"            a[i]=s[len_a-i]-'0';",
			"        }",
			"        cin >> s;",
			"        len_b=s.size();",
			"        for (int i=1; i<=len_b; i++){",
			"            b[i]=s[len_b-i]-'0';",
			"        }",
			"    }",
			"    void add(){",
			"        int tmp=0;",
			"        len=max(len_a, len_b);",
			"        for (int i=1; i<=len; i++){",
			"            sum[i]=a[i]+b[i]+tmp;",
			"            tmp=sum[i]/10;",
			"            sum[i]%=10;",
			"        }",
			"        if (tmp){",
			"            sum[++len]=tmp;",
			"        }",
			"    }",
			"    void out(){",
			"        for (int i=len; i>=1; i--){",
			"            printf(\"%d\", sum[i]);",
			"        }",
			"    }",
			"}",
		],
	},
	"C++ Sub":{
		"prefix": "#sub",
		"body": [
			"struct Sub{",
			"    int len_a, len_b, len;",
			"    int a[N], b[N], sum[N];",
			"    bool flag=0;",
			"    bool check(){",
			"        if (len_a==len_b){",
			"            for (int i=1; i<=len_a; i++){",
			"                if (a[i]<b[i]){",
			"                    return 1;",
			"                }",
			"            }",
			"            return 0;",
			"        }",
			"        if (len_a<len_b){",
			"            return 1;",
			"        }else{",
			"            return 0;",
			"        }",
			"    }",
			"    void in(){",
			"        string s;",
			"        cin >> s;",
			"        len_a=s.size();",
			"        for (int i=1; i<=len_a; i++){",
			"            a[i]=s[len_a-i]-'0';",
			"        }",
			"        cin >> s;",
			"        len_b=s.size();",
			"        for (int i=1; i<=len_b; i++){",
			"            b[i]=s[len_b-i]-'0';",
			"        }",
			"        if (check()){",
			"            for (int i=1; i<=len_a; i++){",
			"                sum[i]=a[i];",
			"            }",
			"            memset(a, 0, sizeof(a));",
			"            for (int i=1; i<=len_b; i++){",
			"                a[i]=b[i];",
			"            }",
			"            memset(b, 0, sizeof(b));",
			"            for (int i=1; i<=len_a; i++){",
			"                b[i]=sum[i];",
			"            }",
			"            swap(len_a, len_b);",
			"            flag=1;",
			"        }",
			"    }",
			"    void sub(){",
			"        int tmp=0;",
			"        len=max(len_a, len_b);",
			"        for (int i=1; i<=len; i++){",
			"            if (a[i]<b[i]){",
			"                a[i+1]--;",
			"                a[i]+=10;",
			"            }",
			"            sum[i]=a[i]-b[i];",
			"        }",
			"        while (!sum[len]&&len>1){",
			"            len--;",
			"        }",
			"    }",
			"    void out(){",
			"        if (flag){",
			"            printf(\"-\");",
			"        }",
			"        for (int i=len; i>=1; i--){",
			"            printf(\"%d\", sum[i]);",
			"        }",
			"    }",
			"}",
		],
	},
	"C++ Mul":{
		"prefix": "#mul",
		"body": [
			"struct Mul{",
			"    int len_a, len_b, len;",
			"    int a[N], b[N], sum[N<<1];",
			"    bool check(){",
			"        if (len_a==len_b){",
			"            for (int i=1; i<=len_a; i++){",
			"                if (a[i]<b[i]){",
			"                    return 1;",
			"                }",
			"            }",
			"            return 0;",
			"        }",
			"        if (len_a<len_b){",
			"            return 1;",
			"        }else{",
			"            return 0;",
			"        }",
			"    }",
			"    void in(){",
			"        string s;",
			"        cin >> s;",
			"        len_a=s.size();",
			"        for (int i=1; i<=len_a; i++){",
			"            a[i]=s[len_a-i]-'0';",
			"        }",
			"        cin >> s;",
			"        len_b=s.size();",
			"        for (int i=1; i<=len_b; i++){",
			"            b[i]=s[len_b-i]-'0';",
			"        }",
			"    }",
			"    void mul(){",
			"        int tmp=0;",
			"        len=len_a+len_b;",
			"        for (int i=1; i<=len_a; i++){",
			"            for (int j=1; j<=len_b; j++){",
			"                tmp=(a[i]*b[j]+sum[i+j-1])/10;",
			"                sum[i+j-1]=(a[i]*b[j]+sum[i+j-1])%10;",
			"                sum[i+j]+=tmp;",
			"            }",
			"        }",
			"        while (!sum[len]&&len>1){",
			"            len--;",
			"        }",
			"    }",
			"    void out(){",
			"        for (int i=len; i>=1; i--){",
			"            printf(\"%d\", sum[i]);",
			"        }",
			"    }",
			"}",
		],
	},
	"C++ Div":{
		"prefix": "#div",
		"body": [
			"struct Sub{",
			"    int len, b, start=1;",
			"    int a[N], sum[N];",
			"    void in(){",
			"        string s;",
			"        cin >> s >> b;",
			"        len=s.size();",
			"        for (int i=1; i<=len; i++){",
			"            a[i]=s[i-1]-'0';",
			"        }",
			"    }",
			"    void div(){",
			"        int tmp=0;",
			"        for (int i=1; i<=len; i++){",
			"            sum[i]=(tmp*10+a[i])/b;",
			"            tmp=(tmp*10+a[i])%b;",
			"        }",
			"        while (!sum[start]&&start<len){",
			"            start++;",
			"        }",
			"    }",
			"    void out(){",
			"        for (int i=start; i<=len; i++){",
			"            printf(\"%d\", sum[i]);",
			"        }",
			"    }",
			"}",
		],
	},
}