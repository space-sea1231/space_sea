{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	"C++ Template":{
		"prefix": "#file",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"int main(){",
			"    // freopen(\"std.in\", \"r\", stdin);",
			"    // freopen(\"std.out\", \"w\", stdout);",
			"    ios::sync_with_stdio(0);",
			"    cin.tie();",
			"",
			"    return 0;",
			"}",
		],
	},
	"C++ Freopen":{
		"prefix": "#freopen",
		"body": [
			"freopen(\"std.in\", \"r\", stdin);",
			"freopen(\"std.out\", \"w\", stdout);",
		],
	},
	"C++ Binary Graph":{
		"prefix":"#bingraph",
		"body": [
			"int match[N];",
			"bool vis[N];",
			"bool dfs(int u){",
			"    for (int i=head[u]; i; i=nxt[i]){",
			"        int v=to[i];",
			"        if (!vis[v]){",
			"            vis[v]=1;",
			"            if (!match[v]||dfs(match[v])){",
			"                match[v]=u;",
			"                return 1;",
			"            }",
			"        }",
			"    }",
			"    return 0;",
			"}",
		],
	},
	"C++ Graph":{
		"prefix": "#graph",
		"body": [
			"int cnt;",
			"int head[N], to[N<<1], nxt[N<<1];",
			"void add(int u, int v){",
			"    to[++cnt]=v;",
			"    nxt[cnt]=head[u];",
			"    head[u]=cnt;",
			"}",
		],
	},
	"C++ Chain_Tree":{
		"prefix": "#chain_tree",
		"body": [
			"struct Chain_Tree{",
			"    int cnt, num=1;",
			"    int head[N], to[N<<1], nxt[N<<1];",
			"    int father[N], dep[N], size[N], son[N];",
			"    int top[N], dfn[N], rev[N];",
			"    void add(int u, int v){",
			"        to[++cnt]=v;",
			"        nxt[cnt]=head[u];",
			"        head[u]=cnt;",
			"    }",
			"    void dfs1(int u, int fa){",
			"        father[u]=fa;",
			"        size[u]=1;",
			"        dep[u]=dep[fa]+1;",
			"        for (int i=head[u]; i; i=nxt[i]){",
			"            int v=to[i];",
			"            if (v!=fa){",
			"                dfs(v, u);",
			"                size[u]+=size[v];",
			"                if (size[v]>size[son[u]]){",
			"                    son[u]=v;",
			"                }",
			"            }",
			"        }",
			"    }",
			"    void dfs2(int u, int fa){",
			"        if (son[u]){",
			"            dfn[son[u]]=++num;",
			"            top[son[u]]=top[u];",
			"            rev[num]=son[u];",
			"            dfs2(son[u], u);",
			"        }",
			"        for (int i=head[u]; i; i=nxt[i]){",
			"            int v=to[i];",
			"            if (!dfn[v]){",
			"                dfn[v]=++num;",
			"                top[v]=v;",
			"                rev[num]=v;",
			"                dfs2(v, u);",
			"            }",
			"        }",
			"    }",
			"    void init(){",
			"        dfn[1]=top[1]=rev[1]=1;",
			"        dfs1(1, 0);",
			"        dfs2(1, 0);",
			"    }",
			"};",
		],
	},
	"C++ Segment Tree":{
		"prefix": "#segment_tree_add",
		"body": [
			"struct Segment_Tree{",
			"    struct Node{",
			"        int sum, vis;",
			"    }e[N<<2];",
			"    void Build(int x, int l, int r){",
			"        if (l==r){",
			"            e[x].sum=a[l];",
			"            return ;",
			"        }",
			"        int mid=(l+r)>>1;",
			"        Build(x<<1, l, mid);",
			"        Build(x<<1|1, mid+1, r);",
			"        e[x].sum=e[x<<1].sum+e[x<<1|1].sum;",
			"    }",
			"    void Down(int x, int l, int r){",
			"        int mid=(l+r)>>1;",
			"        e[x<<1].vis+=e[x].vis;",
			"        e[x<<1|1].vis+=e[x].vis;",
			"        e[x<<1].sum+=(mid-l+1)*e[x].vis;",
			"        e[x<<1|1].sum+=(r-mid)*e[x].vis;",
			"        e[x].vis=0;",
			"    }",
			"    void Add(int x, int l, int r, int L, int R, int w){",
			"        if (L<=l&&r<=R){",
			"            e[x].vis+=w;",
			"            e[x].sum+=(r-l+1)*w;",
			"            return ;",
			"        }",
			"        ",
			"        Down(x, l, r);",
			"        int mid=(l+r)>>1;",
			"        if (L<=mid){",
			"            Add(x<<1, l, mid, L, R, w);",
			"        }",
			"        if (mid+1<=R){",
			"            Add(x<<1|1, mid+1, r, L, R, w);",
			"        }",
			"        e[x].sum=e[x<<1].sum+e[x<<1|1].sum;",
			"    }",
			"    int Query(int x, int l, int r, int L, int R){",
			"        if (L<=l&&r<=R){",
			"            return e[x].sum;",
			"        }",
			"        Down(x, l, r);",
			"        int mid=(l+r)>>1, ans=0;",
			"        if (L<=mid){",
			"            ans+=Query(x<<1, l, mid, L, R);",
			"        }",
			"        if (mid+1<=R){",
			"            ans+=Query(x<<1|1, mid+1, r, L, R);",
			"        }",
			"        return ans;",
			"    }",
			"}",
		],
	},
	"C++ Li_Chao_Segment_Tree":{
		"prefix": "#li_chao_segment_tree",
		"body": [
			"struct Li_Chao_Segment_Tree{",
			"    int cnt;",
			"    int vis[N<<1];",
			"    struct Node{",
			"        double k, b;",
			"    }e[N<<1];",
			"    void Add(int sx, int sy, int fx, int fy){",
			"        cnt++;",
			"        if (sx==sy){",
			"            e[cnt].k=0;",
			"            e[cnt].b=max(sy, fy);",
			"        }else{",
			"            e[cnt].k=1.0*(fy-sy)/(fx-sx);",
			"            e[cnt].b=sy-e[cnt].k*sx;",
			"        }",
			"    }",
			"    double Calc(int x, int val){",
			"        return e[x].k*val+e[x].b;",
			"    }",
			"    int Check(double x, double y){",
			"        if (x-y>eps){",
			"            return 1;",
			"        }",
			"        if (y-x>eps){",
			"            return -1;",
			"        }",
			"        return 0;",
			"    }",
			"    void Down(int root, int l, int r, int u){",
			"        int &v=vis[root], mid=(l+r)>>1;",
			"        int check_mid=Check(Calc(u, mid), Calc(v, mid));",
			"        if (check_mid==1||(check_mid==0&&u<v)){",
			"            swap(u, v);",
			"        }",
			"        int check_l=Check(Calc(u, l), Calc(v, l));",
			"        int check_r=Check(Calc(u, r), Calc(v, r));",
			"        if (check_l==1||(check_l==0&&u<v)){",
			"            Down(root<<1, l, mid, u);",
			"        }",
			"        if (check_r==1||(check_r==0&&u<v)){",
			"            Down(root<<1|1, mid+1, r, u);",
			"        }",
			"    }",
			"    void Update(int root, int l, int r, int L, int R, int u){",
			"        if (L<=l&&r<=R){",
			"            Down(root, l, r, u);",
			"            return ;",
			"        }",
			"        int mid=(l+r)>>1;",
			"        if (L<=mid){",
			"            Update(root<<1, l, mid, L, R, u);",
			"        }",
			"        if (mid+1<=R){",
			"            Update(root<<1|1, mid+1, r, L, R, u);",
			"        }",
			"    }",
			"    Pair Max(Pair x, Pair y){",
			"        if (x.second-y.second>eps){",
			"            return x;",
			"        }",
			"        if (y.second-x.second>eps){",
			"            return y;",
			"        }",
			"        if (x.first<y.first){",
			"            return x;",
			"        }else{",
			"            return y;",
			"        }",
			"    }",
			"    Pair Query(int root, int l, int r, int x){",
			"        if (x<l||r<x){",
			"            return {0, 0};",
			"        }",
			"        int mid=(l+r)>>1;",
			"        double ans=Calc(vis[root], x);",
			"        if (l==r){",
			"            return {vis[root], ans};",
			"        }",
			"        return Max({vis[root], ans}, Max(Query(root<<1, l, mid, x), Query(root<<1|1, mid+1, r, x)));",
			"    }",
			"}",
		],
	},
	"C++ Segment_Tree_Mul":{
		"prefix": "#segment_tree_mul",
		"body": [
			"struct Segment_Tree{",
			"    struct Node{",
			"        int sum, vis_add, vis_mul;",
			"    }e[N<<1];",
			"    void Build(int x, int l, int r){",
			"        int mid=(l+r)>>1;",
			"        e[x].vis_mul=1;",
			"        if (l==r){",
			"            e[x].sum=a[l];",
			"            return;",
			"        }",
			"        Build(x<<1, l, mid);",
			"        Build(x<<1|1, mid+1, r);",
			"        e[x].sum+=e[x<<1|1].sum;",
			"    }",
			"    void Down(int x, int l, int r){",
			"        int mid=(l+r)>>1;",
			"        e[x<<1].sum=e[x<<1].sum*e[x].vis_mul+(mid-l+1)*e[x].vis_add;",
			"        e[x<<1|1].sum=e[x<<1|1].sum*e[x].vis_mul+(r-mid)*e[x].vis_add;",
			"        e[x<<1].vis_add=e[x<<1].vis_add*e[x].vis_mul+e[x].vis_add;",
			"        e[x<<1|1].vis_add=e[x<<1|1].vis_add*e[x].vis_mul+e[x].vis_add;",
			"        e[x<<1].vis_mul*=e[x].vis_mul;",
			"        e[x<<1|1].vis_mul*=e[x].vis_mul;",
			"        e[x].vis_add=0, e[x].vis_mul=1;",
			"    }",
			"    void Mul(int x, int l, int r, int L, int R, int w){",
			"        if (L<=l&&r<=R){",
			"            e[x].vis_add=e[x].vis_add*w;",
			"            e[x].vis_mul=e[x].vis_mul*w;",
			"            e[x].sum=e[x].sum*w;",
			"            return;",
			"        }",
			"        Down(x, l, r);",
			"        int mid=(l+r)>>1;",
			"        if (L<=mid){",
			"            Mul(x<<1, l, mid, L, R, w);",
			"        }",
			"        if (mid+1<=R){",
			"            Mul(x<<1|1, mid+1, r, L, R, w);",
			"        }",
			"        e[x].sum=e[x<<1].sum+e[x<<1|1].sum;",
			"    }",
			"    void Add(int x, int l, int r, int L, int R, int w){",
			"        if (L<=l&&r<=R){",
			"            e[x].vis_add+=w;",
			"            e[x].sum+=(r-l+1)*w;",
			"            return;",
			"        }",
			"        Down(x, l, r);",
			"        int mid=(l+r)>>1;",
			"        if (L<=mid){",
			"            Add(x<<1, l, mid, L, R, w);",
			"        }",
			"        if (mid+1<=R){",
			"            Add(x<<1|1, mid+1, r, L, R, w);",
			"        }",
			"        e[x].sum=e[x<<1].sum+e[x<<1|1].sum;",
			"    }",
			"    int Query(int x, int l, int r, int L, int R){",
			"        if (L<=l&&r<=R){",
			"            return e[x].sum;",
			"        }",
			"        Down(x, l, r);",
			"        int mid=(l+r)>>1, ans=0;",
			"        if (L<=mid){",
			"            ans+=Query(x<<1, l, mid, L, R);",
			"        }",
			"        if (mid+1<=R){",
			"            ans+=Query(x<<1|1, mid+1, r, L, R);",
			"        }",
			"        return ans;",
			"    }",
			"};",
		],
	},
	"C++ Binary_Indexed_Tree":{
		"prefix": "#binary_indexed_tree",
		"body": [
			"struct Binary_Indexed_Tree{",
			"    int num[N];",
			"    int lowbit(int x){",
			"        return x&-x;",
			"    }",
			"    void add(int x, int y){",
			"        for (int i=x; i<=n; i+=lowbit(i)){",
			"            num[i]+=y;",
			"        }",
			"    }",
			"    int sum(int x){",
			"        int ans=0;",
			"        for (int i=x; i>=1; i-=lowbit(i)){",
			"            ans+=num[i];",
			"        }",
			"        return ans;",
			"    }",
			"};",
		],
	},
	"C++ Trie_Tree":{
		"prefix": "#trie_tree",
		"body": [
			"struct Trie_Tree{",
			"    int num=1;",
			"    int ch[N][Z], sum[N];",
			"    bool ed[N];",
			"    void init(){",
			"        memset(ch, 0, sizeof(ch));",
			"        memset(ed, 0, sizeof(ed));",
			"        memset(sum, 0, sizeof(sum));",
			"        num=1;",
			"    }",
			"    int change(char c){",
			"        if ('A'<=c&&c<='Z'){",
			"            return c-'A';",
			"        }",
			"        if ('a'<=c&&c<='z'){",
			"            return c-'a'+26;",
			"        }",
			"        return c-'0'+52;",
			"    }",
			"    void add(string s){",
			"        int u=1, len=s.size();",
			"        for (int i=0; i<len; i++){",
			"            int c=change(s[i]);",
			"            if (!ch[u][c]){",
			"                ch[u][c]=++num;",
			"            }",
			"            u=ch[u][c];",
			"            sum[u]++;",
			"        }",
			"        ed[u]=1;",
			"    }",
			"    int find(string s){",
			"        int u=1, len=s.size();",
			"        for (int i=0; i<len; i++){",
			"            int c=change(s[i]);",
			"            if (!ch[u][c]){",
			"                return 0;",
			"            }",
			"            u=ch[u][c];",
			"        }",
			"        return sum[u];",
			"    }",
			"};",
		],
	},
	"C++ Treap":{
		"prefix": "#treap",
		"body": [
			"struct Treap{",
			"    int num=0, root;",
			"    struct Node{",
			"        int l, r;",
			"        int vis, val;",
			"        int cnt, size;",
			"    }e[N<<1];",
			"    void Update(int x){",
			"        e[x].size=e[e[x].l].size+e[e[x].r].size+e[x].cnt;",
			"    }",
			"    void Zig(int &x){",
			"        int y=e[x].l;",
			"        e[x].l=e[y].r;",
			"        e[y].r=x, x=y;",
			"        Update(e[x].r);",
			"        Update(x);",
			"    }",
			"    void Zag(int &x){",
			"        int y=e[x].r;",
			"        e[x].r=e[y].l;",
			"        e[y].l=x, x=y;",
			"        Update(e[x].l);",
			"        Update(x);",
			"    }",
			"    int New(int val){",
			"        e[++num].val=val;",
			"        e[num].vis=rand();",
			"        e[num].size=1;",
			"        e[num].cnt=1;",
			"        return num;",
			"    }",
			"    void Insert(int &x, int val){",
			"        if (x==0){",
			"            x=New(val);",
			"            Update(x);",
			"            return ;",
			"        }",
			"        if (val==e[x].val){",
			"            e[x].cnt++;",
			"            Update(x);",
			"            return ;",
			"        }",
			"        if (val<e[x].val){",
			"            Insert(e[x].l, val);",
			"            if (e[x].vis<e[e[x].l].vis){",
			"                Zig(x);",
			"            }",
			"        }else{",
			"            Insert(e[x].r, val);",
			"            if (e[x].vis<e[e[x].r].vis){",
			"                Zag(x);",
			"            }",
			"        }",
			"        Update(x);",
			"    }",
			"    void Remove(int &x, int val){",
			"        if (x==0){",
			"            return ;",
			"        }",
			"        if (val==e[x].val){",
			"            if (e[x].cnt>1){",
			"                e[x].cnt--;",
			"                Update(x);",
			"                return ;",
			"            }",
			"            if (e[x].l||e[x].r){",
			"                if (e[x].r==0||e[e[x].l].vis>e[e[x].r].vis){",
			"                    Zig(x);",
			"                    Remove(e[x].r, val);",
			"                }else{",
			"                    Zag(x);",
			"                    Remove(e[x].l, val);",
			"                }",
			"            }else{",
			"                x=0;",
			"            }",
			"        }else{",
			"            if (val<e[x].val){",
			"                Remove(e[x].l, val);",
			"            }else{",
			"                Remove(e[x].r, val);",
			"            }",
			"        }",
			"        Update(x);",
			"    }",
			"    int Val_Rank(int x, int val){",
			"        if (x==0){",
			"            return 1;",
			"        }",
			"        if (val==e[x].val){",
			"            return e[e[x].l].size+1;",
			"        }",
			"        if (val<e[x].val){",
			"            return Val_Rank(e[x].l, val);",
			"        }else{",
			"            return Val_Rank(e[x].r, val)+e[e[x].l].size+e[x].cnt;",
			"        }",
			"    }",
			"    int Rank_Val(int x, int rank){",
			"        if (x==0){",
			"            return INF;",
			"        }",
			"        if (e[e[x].l].size>=rank){",
			"            return Rank_Val(e[x].l, rank);",
			"        }",
			"        if (e[e[x].l].size+e[x].cnt>=rank){",
			"            return e[x].val;",
			"        }",
			"        return Rank_Val(e[x].r, rank-e[e[x].l].size-e[x].cnt);",
			"    }",
			"    int Pre(int x, int val){",
			"        if (x==0){",
			"            return -INF;",
			"        }",
			"        if (e[x].val<val){",
			"            return max(e[x].val, Pre(e[x].r, val));",
			"        }else{",
			"            return Pre(e[x].l, val);",
			"        }",
			"    }",
			"    int Nxt(int x, int val){",
			"        if (x==0){",
			"            return INF;",
			"        }",
			"        if (e[x].val>val){",
			"            return min(e[x].val, Nxt(e[x].l, val));",
			"        }else{",
			"            return Nxt(e[x].r, val);",
			"        }",
			"    }",
			"};",
		],
	},
	"C++ Splay":{
		"prefix": "#splay",
		"body": [
			"struct Splay{",
			"    int root, num;",
			"    struct Node{",
			"        int fa, val;",
			"        int size, cnt;",
			"        int son[2];",
			"    }e[N];",
			"    void Update(int x){",
			"        e[x].size=e[e[x].lson].size+e[e[x].rson].size+e[x].cnt;",
			"    }",
			"    bool Check(int x){",
			"        return x==e[e[x].fa].rson;",
			"    }",
			"    void Clear(int x){",
			"        e[x].fa=0, e[x].val=0;",
			"        e[x].size=0, e[x].cnt=0;",
			"        e[x].rson=0, e[x].lson=0;",
			"    }",
			"    void New(int x){",
			"        e[++num].val=x;",
			"        e[num].cnt++;",
			"    }",
			"    void Rotate(int x){",
			"        int y=e[x].fa, z=e[y].fa, to=Check(x);",
			"        e[y].son[to]=e[x].son[to^1];",
			"        if (e[x].son[to^1]){",
			"            e[e[x].son[to^1]].fa=y;",
			"        }",
			"        e[x].son[to^1]=y;",
			"        e[y].fa=x, e[x].fa=z;",
			"        if (z){",
			"            e[z].son[e[z].rson==y]=x;",
			"        }",
			"        Update(y);",
			"        Update(x);",
			"    }",
			"    void splay(int x){",
			"        for (int i=e[x].fa; i=e[x].fa, i; Rotate(x)){",
			"            if (e[i].fa){",
			"                Rotate(Check(x)==Check(i)?i:x);",
			"            }",
			"        }",
			"        root=x;",
			"    }",
			"    void Insert(int x){",
			"        if (!root){",
			"            New(x);",
			"            Update(num);",
			"            root=num;",
			"            return ;",
			"        }",
			"        int cur=root, last=0;",
			"        while (1){",
			"            if (e[cur].val==x){",
			"                e[cur].cnt++;",
			"                Update(cur);",
			"                Update(last);",
			"                splay(cur);",
			"                return ;",
			"            }",
			"            last=cur, cur=e[cur].son[x>e[cur].val];",
			"            if (!cur){",
			"                New(x);",
			"                e[num].fa=last;",
			"                e[last].son[x>e[last].val]=num;",
			"                Update(num);",
			"                Update(last);",
			"                splay(num);",
			"                return ;",
			"            }",
			"        }",
			"    }",
			"    int Pre(){",
			"        int cur=e[root].lson;",
			"        if (!cur){",
			"            return cur;",
			"        }",
			"        while (e[cur].rson){",
			"            cur=e[cur].rson;",
			"        }",
			"        splay(cur);",
			"        return cur;",
			"    }",
			"    int Nxt(){",
			"        int cur=e[root].rson;",
			"        if (!cur){",
			"            return cur;",
			"        }",
			"        while (e[cur].lson){",
			"            cur=e[cur].lson;",
			"        }",
			"        splay(cur);",
			"        return cur;",
			"    }",
			"    int Val_Rank(int x){",
			"        int ans=0, cur=root;",
			"        while (1){",
			"            if (x<e[cur].val){",
			"                cur=e[cur].lson;",
			"                continue;",
			"            }",
			"            ans+=e[e[cur].lson].size;",
			"            if (!cur){",
			"                return ans+1;",
			"            }",
			"            if (e[cur].val==x){",
			"                splay(cur);",
			"                return ans+1;",
			"            }",
			"            ans+=e[cur].cnt;",
			"            cur=e[cur].rson;",
			"        }",
			"    }",
			"    int Rank_Val(int x){",
			"        int cur=root;",
			"        while (1){",
			"            if (e[cur].lson&&x<=e[e[cur].lson].size){",
			"                cur=e[cur].lson;",
			"                continue;",
			"            }",
			"            x-=e[e[cur].lson].size+e[cur].cnt;",
			"            if (x<=0){",
			"                splay(cur);",
			"                return e[cur].val;",
			"            }",
			"            cur=e[cur].rson;",
			"        }",
			"    }",
			"    void Delete(int x){",
			"        Val_Rank(x);",
			"        if (e[root].cnt>1){",
			"            e[root].cnt--;",
			"            Update(root);",
			"            return ;",
			"        }",
			"        if (!e[root].lson&&!e[root].rson){",
			"            Clear(root);",
			"            root=0;",
			"            return ;",
			"        }",
			"        if (!e[root].lson){",
			"            int cur=root;",
			"            root=e[root].rson;",
			"            e[root].fa=0;",
			"            Clear(cur);",
			"            return ;",
			"        }",
			"        if (!e[root].rson){",
			"            int cur=root;",
			"            root=e[root].lson;",
			"            e[root].fa=0;",
			"            Clear(cur);",
			"            return ;",
			"        }",
			"        int cur=root;",
			"        int tmp=Pre();",
			"        e[e[cur].rson].fa=tmp;",
			"        e[tmp].rson=e[cur].rson;",
			"        Clear(cur);",
			"        Update(root);",
			"    }",
			"}",
		]
	},
	"C++ Pairing_Heap":{
		"prefix": "#pairing_tree",
		"body": [
			"struct Pairng_Heap{",
			"    struct Node{",
			"        int val, fa;",
			"        int to, nxt;",
			"        bool flag;",
			"    }e[N];",
			"    int Find(int x){",
			"        if (x==e[x].fa){",
			"            return x;",
			"        }",
			"        return e[x].fa=Find(e[x].fa);",
			"    }",
			"    int Merge(int x, int y){",
			"        if (x==0||y==0||x==y){",
			"            return x?x:y;",
			"        }",
			"        if (e[x].val>e[y].val||(e[x].val==e[y].val&&x>y)){",
			"            swap(x, y);",
			"        }",
			"        e[y].nxt=e[x].to;",
			"        e[x].to=y;",
			"        return e[y].fa=x;",
			"    }",
			"    int Merges(int x){",
			"        if (x==0){",
			"            return 0;",
			"        }",
			"        e[x].fa=x;",
			"        if (!e[x].nxt){",
			"            return x;",
			"        }",
			"        int y=e[x].nxt;",
			"        int z=e[y].nxt;",
			"        e[x].nxt=0, e[y].nxt=0;",
			"        e[y].fa=y;",
			"        return Merge(Merges(z), Merge(x, y));",
			"    }",
			"    int Query(int x){",
			"        if (e[x].flag){",
			"            int fx=Find(x);",
			"            e[fx].flag=0;",
			"            e[fx].fa=Merges(e[fx].to);",
			"            return e[fx].val;",
			"        }else{",
			"            return -1;",
			"        }",
			"    }",
			"    void Init(){",
			"        for (int i=1; i<=n; i++){",
			"            e[i].val=a[i];",
			"            e[i].fa=i, e[i].flag=1;",
			"        }",
			"    }",
			"}",
		],
	},
	"C++ Leftist_Tree":{
		"prefix": "#leftist_tree",
		"body": [
			"struct Leftist_Tree{",
			"    struct Node{",
			"        int dist, val;",
			"        int lson, rson;",
			"        int fa, flag;",
			"        int id;",
			"    }e[N];",
			"    int Find(int x){",
			"        if (e[x].fa==x){",
			"            return x;",
			"        }",
			"        return e[x].fa=Find(e[x].fa);",
			"    }",
			"    int &Rson(int x){",
			"        if (e[rson].dist<e[lson].dist){",
			"            return e[x].rson;",
			"        }else{",
			"            return e[x].lson;",
			"        }",
			"    }",
			"    int Merge(int x, int y){",
			"        if (!x||!y){",
			"            return x|y;",
			"        }",
			"        if (e[x].val>e[y].val||(e[x].val==e[y].val&&e[x].id>e[y].id)){",
			"            swap(x, y);",
			"        }",
			"        int &rson=Rson(x);",
			"        rson=Merge(rson, y);",
			"        e[x].dist=e[rson].dist+1;",
			"        return e[rson].fa=x;",
			"    }",
			"    void PushUp(int x){",
			"        if (!x){",
			"            return ;",
			"        }",
			"        if (e[x].dist!=e[Rson(x)].dist+1){",
			"            e[x].dist=e[Rson(x)].dist+1;",
			"            PushUp(e[x].fa);",
			"        }",
			"    }",
			"    void Merges(int x){",
			"        int y=Merge(e[x].lson, e[x].rson);",
			"        e[y].fa=e[x].fa;",
			"        if (e[e[x].fa].lson==x){",
			"            e[e[x].fa].lson=y;",
			"        }",
			"        if (e[e[x].fa].rson==x){",
			"            e[e[x].fa].rson=y;",
			"        }",
			"        PushUp(e[x].fa);",
			"        e[x].fa=y;",
			"        e[e[x].lson].fa=y;",
			"        e[e[x].rson].fa=y;",
			"    }",
			"    int Query(int x){",
			"        if (e[x].flag){",
			"            int fx=Find(x);",
			"            e[fx].flag=0;",
			"            Merges(fx);",
			"            return e[fx].val;",
			"        }else{",
			"            return -1;",
			"        }",
			"    }",
			"    void Init(){",
			"        e[0].dist=-1;",
			"        for (int i=1; i<=n; i++){",
			"            e[i].val=a[i], e[i].flag=1;",
			"            e[i].fa=i, e[i].id=i;",
			"        }",
			"    }",
			"}",
		]
	},
	"C++ Blocking_Add":{
		"prefix": "#blocking_Add",
		"body": [
			"struct Blocking{",
			"    int siz;",
			"    int L[N], R[N];",
			"    int pos[N], sum[N], vis[N];",
			"    void Add(int l, int r, int w){",
			"        int x=pos[l], y=pos[r];",
			"        if (x==y){",
			"            for (int i=l; i<=r; i++){",
			"                a[i]+=w;",
			"            }",
			"            sum[x]+=(r-l+1)*w;  ",
			"        }else{",
			"            for (int i=l; i<=R[x]; i++){",
			"                a[i]+=w;",
			"            }",
			"            sum[x]+=(R[x]-l+1)*w;",
			"            for (int i=L[y]; i<=r; i++){",
			"                a[i]+=w;",
			"            }",
			"            sum[y]+=(r-L[y]+1)*w;",
			"            for (int i=x+1; i<=y-1; i++){",
			"                vis[i]+=w;",
			"            }",
			"        }",
			"    }",
			"    int Query(int l, int r){",
			"        int x=pos[l], y=pos[r];",
			"        int ans=0;",
			"        if (x==y){",
			"            for (int i=l; i<=r; i++){",
			"                ans+=a[i];",
			"            }",
			"            ans+=(r-l+1)*vis[x];",
			"        }else{",
			"            for (int i=l; i<=R[x]; i++){",
			"                ans+=a[i]+vis[x];",
			"            }",
			"            for (int i=L[y]; i<=r; i++){",
			"                ans+=a[i]+vis[y];",
			"            }",
			"            for (int i=x+1; i<=y-1; i++){",
			"                ans+=sum[i]+vis[i]*(R[i]-L[i]+1);",
			"            }",
			"        }",
			"        return ans;",
			"    }",
			"    void Init(){",
			"        siz=sqrt(n);",
			"        for (int i=1; i<=n; i++){",
			"            L[i]=(i-1)*siz+1;",
			"            R[i]=i*siz;",
			"        }",
			"        if (R[siz]<n){",
			"            siz++;",
			"            L[siz]=R[siz-1]+1;",
			"            R[siz]=n;",
			"        }",
			"        for (int i=1; i<=siz; i++){",
			"            for (int j=L[i]; j<=R[i]; j++){",
			"                pos[j]=i;",
			"                sum[i]+=a[j];",
			"            }",
			"        }",
			"    }",
			"}",
		],
	},
	"C++ Blocking_Mul":{
		"prefix": "#blocking_mul",
		"body": [
			"struct Blocking{",
		"    int siz;",
		"    int L[N], R[N];",
		"    int pos[N], sum[N];",
		"    int visa[N], vism[N];",
		"    void Down(int x){",
		"        for (int i=L[x]; i<=R[x]; i++){",
		"            a[i]=(a[i]*vism[x]+visa[x])%q;",
		"        }",
		"        visa[x]=0, vism[x]=1;",
		"    }",
		"    void Add(int l, int r, int w){",
		"        int x=pos[l], y=pos[r];",
		"        if (x==y){",
		"            Down(x);",
		"            for (int i=l; i<=r; i++){",
		"                a[i]=(a[i]+w)%q;",
		"            }",
		"            sum[x]=(sum[x]+(r-l+1)*w)%q;  ",
		"        }else{",
		"            Down(x), Down(y);",
		"            for (int i=l; i<=R[x]; i++){",
		"                a[i]=(a[i]+w)%q;",
		"            }",
		"            sum[x]=(sum[x]+(R[x]-l+1)*w)%q;",
		"            for (int i=L[y]; i<=r; i++){",
		"                a[i]=(a[i]+w)%q;",
		"            } ",
		"            sum[y]=(sum[y]+(r-L[y]+1)*w)%q;",
		"            for (int i=x+1; i<=y-1; i++){",
		"                visa[i]=(visa[i]+w)%q;",
		"                sum[i]=(sum[i]+(R[i]-L[i]+1)*w)%q;",
		"            }",
		"        }",
		"    }",
		"    void Mul(int l, int r, int w){",
		"        int x=pos[l], y=pos[r];",
		"        if (x==y){",
		"            Down(x);",
		"            for (int i=l; i<=r; i++){",
		"                sum[x]=(sum[x]+(a[i]*(w-1)))%q;",
		"                a[i]=(a[i]*w)%q;",
		"            }",
		"        }else{",
		"            Down(x), Down(y);",
		"            for (int i=l; i<=R[x]; i++){",
		"                sum[x]=(sum[x]+(a[i]*(w-1)))%q;",
		"                a[i]=(a[i]*w)%q;",
		"            }",
		"            for (int i=L[y]; i<=r; i++){",
		"                sum[y]=(sum[y]+(a[i]*(w-1)))%q;",
		"                a[i]=(a[i]*w)%q;",
		"            }",
		"            for (int i=x+1; i<=y-1; i++){",
		"                visa[i]=(visa[i]*w)%q;",
		"                vism[i]=(vism[i]*w)%q;",
		"                sum[i]=(sum[i]*w)%q;",
		"            }",
		"        }",
		"    }",
		"    int Query(int l, int r){",
		"        int x=pos[l], y=pos[r];",
		"        int ans=0;",
		"        if (x==y){",
		"            for (int i=l; i<=r; i++){",
		"                ans=(ans+a[i])%q;",
		"            }",
		"            ans=(ans*vism[x]+(r-l+1)*visa[x])%q;",
		"        }else{",
		"            for (int i=l; i<=R[x]; i++){",
		"                ans=(ans+a[i]*vism[x]+visa[x])%q;",
		"            }",
		"            for (int i=L[y]; i<=r; i++){",
		"                ans=(ans+a[i]*vism[y]+visa[y])%q;",
		"            }",
		"            for (int i=x+1; i<=y-1; i++){",
		"                ans=(ans+sum[i])%q;",
		"            }",
		"        }",
		"        return (ans+q)%q;",
		"    }",
		"    void Init(){",
		"        siz=sqrt(n);",
		"        for (int i=1; i<=n; i++){",
		"            L[i]=(i-1)*siz+1;",
		"            R[i]=i*siz;",
		"        }",
		"        if (R[siz]<n){",
		"            siz++;",
		"            L[siz]=R[siz-1]+1;",
		"            R[siz]=n;",
		"        }",
		"        for (int i=1; i<=siz; i++){",
		"            for (int j=L[i]; j<=R[i]; j++){",
		"                pos[j]=i;",
		"                sum[i]=(sum[i]+a[j])%q;",
		"            }",
		"            vism[i]=1;",
		"        }",
		"    }",
		"}",
		],
	},
	"C++ Sparse_Table":{
		"prefix": "#spares_table",
		"body": [
			"struct Sparse_Table{",
			"    int dp[N][Z], lg[N];",
			"    Sparse_Table(){",
			"        lg[0]=-1;",
			"        for (int i=1; i<N; i++){",
			"            lg[i]=lg[i>>1]+1;",
			"        }",
			"    }",
			"    void Init(){",
			"        for (int j=1; j<=lg[n]; j++){",
			"            for (int i=1; i+(1<<j)-1<=n; i++){",
			"                dp[i][j]=max(dp[i][j-1], dp[i+(1<<(j-1))][j-1]);",
			"            }",
			"        }",
			"    }",
			"    int Query(int l, int r){",
			"        int len=lg[r-l+1];",
			"        return max(dp[l][len], dp[r-(1<<len)+1][len]);",
			"    }",
			"}",
		],
	},
	"C++ Add":{
		"prefix": "#add",
		"body": [
			"struct Add{",
			"    int len_a, len_b, len;",
			"    int a[N], b[N], sum[N];",
			"    void in(){",
			"        string s;",
			"        cin >> s;",
			"        len_a=s.size();",
			"        for (int i=1; i<=len_a; i++){",
			"            a[i]=s[len_a-i]-'0';",
			"        }",
			"        cin >> s;",
			"        len_b=s.size();",
			"        for (int i=1; i<=len_b; i++){",
			"            b[i]=s[len_b-i]-'0';",
			"        }",
			"    }",
			"    void add(){",
			"        int tmp=0;",
			"        len=max(len_a, len_b);",
			"        for (int i=1; i<=len; i++){",
			"            sum[i]=a[i]+b[i]+tmp;",
			"            tmp=sum[i]/10;",
			"            sum[i]%=10;",
			"        }",
			"        if (tmp){",
			"            sum[++len]=tmp;",
			"        }",
			"    }",
			"    void out(){",
			"        for (int i=len; i>=1; i--){",
			"            printf(\"%d\", sum[i]);",
			"        }",
			"    }",
			"}",
		],
	},
	"C++ Sub":{
		"prefix": "#sub",
		"body": [
			"struct Sub{",
			"    int len_a, len_b, len;",
			"    int a[N], b[N], sum[N];",
			"    bool flag=0;",
			"    bool check(){",
			"        if (len_a==len_b){",
			"            for (int i=1; i<=len_a; i++){",
			"                if (a[i]<b[i]){",
			"                    return 1;",
			"                }",
			"            }",
			"            return 0;",
			"        }",
			"        if (len_a<len_b){",
			"            return 1;",
			"        }else{",
			"            return 0;",
			"        }",
			"    }",
			"    void in(){",
			"        string s;",
			"        cin >> s;",
			"        len_a=s.size();",
			"        for (int i=1; i<=len_a; i++){",
			"            a[i]=s[len_a-i]-'0';",
			"        }",
			"        cin >> s;",
			"        len_b=s.size();",
			"        for (int i=1; i<=len_b; i++){",
			"            b[i]=s[len_b-i]-'0';",
			"        }",
			"        if (check()){",
			"            for (int i=1; i<=len_a; i++){",
			"                sum[i]=a[i];",
			"            }",
			"            memset(a, 0, sizeof(a));",
			"            for (int i=1; i<=len_b; i++){",
			"                a[i]=b[i];",
			"            }",
			"            memset(b, 0, sizeof(b));",
			"            for (int i=1; i<=len_a; i++){",
			"                b[i]=sum[i];",
			"            }",
			"            swap(len_a, len_b);",
			"            flag=1;",
			"        }",
			"    }",
			"    void sub(){",
			"        int tmp=0;",
			"        len=max(len_a, len_b);",
			"        for (int i=1; i<=len; i++){",
			"            if (a[i]<b[i]){",
			"                a[i+1]--;",
			"                a[i]+=10;",
			"            }",
			"            sum[i]=a[i]-b[i];",
			"        }",
			"        while (!sum[len]&&len>1){",
			"            len--;",
			"        }",
			"    }",
			"    void out(){",
			"        if (flag){",
			"            printf(\"-\");",
			"        }",
			"        for (int i=len; i>=1; i--){",
			"            printf(\"%d\", sum[i]);",
			"        }",
			"    }",
			"}",
		],
	},
	"C++ Mul":{
		"prefix": "#mul",
		"body": [
			"struct Mul{",
			"    int len_a, len_b, len;",
			"    int a[N], b[N], sum[N<<1];",
			"    bool check(){",
			"        if (len_a==len_b){",
			"            for (int i=1; i<=len_a; i++){",
			"                if (a[i]<b[i]){",
			"                    return 1;",
			"                }",
			"            }",
			"            return 0;",
			"        }",
			"        if (len_a<len_b){",
			"            return 1;",
			"        }else{",
			"            return 0;",
			"        }",
			"    }",
			"    void in(){",
			"        string s;",
			"        cin >> s;",
			"        len_a=s.size();",
			"        for (int i=1; i<=len_a; i++){",
			"            a[i]=s[len_a-i]-'0';",
			"        }",
			"        cin >> s;",
			"        len_b=s.size();",
			"        for (int i=1; i<=len_b; i++){",
			"            b[i]=s[len_b-i]-'0';",
			"        }",
			"    }",
			"    void mul(){",
			"        int tmp=0;",
			"        len=len_a+len_b;",
			"        for (int i=1; i<=len_a; i++){",
			"            for (int j=1; j<=len_b; j++){",
			"                tmp=(a[i]*b[j]+sum[i+j-1])/10;",
			"                sum[i+j-1]=(a[i]*b[j]+sum[i+j-1])%10;",
			"                sum[i+j]+=tmp;",
			"            }",
			"        }",
			"        while (!sum[len]&&len>1){",
			"            len--;",
			"        }",
			"    }",
			"    void out(){",
			"        for (int i=len; i>=1; i--){",
			"            printf(\"%d\", sum[i]);",
			"        }",
			"    }",
			"}",
		],
	},
	"C++ Div":{
		"prefix": "#div",
		"body": [
			"struct Sub{",
			"    int len, b, start=1;",
			"    int a[N], sum[N];",
			"    void in(){",
			"        string s;",
			"        cin >> s >> b;",
			"        len=s.size();",
			"        for (int i=1; i<=len; i++){",
			"            a[i]=s[i-1]-'0';",
			"        }",
			"    }",
			"    void div(){",
			"        int tmp=0;",
			"        for (int i=1; i<=len; i++){",
			"            sum[i]=(tmp*10+a[i])/b;",
			"            tmp=(tmp*10+a[i])%b;",
			"        }",
			"        while (!sum[start]&&start<len){",
			"            start++;",
			"        }",
			"    }",
			"    void out(){",
			"        for (int i=start; i<=len; i++){",
			"            printf(\"%d\", sum[i]);",
			"        }",
			"    }",
			"}",
		],
	},
}